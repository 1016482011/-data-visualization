

/* Copyright (c) 2016, xBIM Team, Northumbria University. All rights reserved.

This javascript library is part of xBIM project. It is provided under the same 
Common Development and Distribution License (CDDL) as the xBIM Toolkit. For 
more information see http://www.openbim.org

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 29);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/* no static exports found */
/* all exports used */
/*!*************************!*\
  !*** ./Viewer/state.ts ***!
  \*************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n    * Enumeration for object states.\n    * @readonly\n    * @enum {number}\n    */\nvar State;\n(function (State) {\n    State[State[\"UNDEFINED\"] = 255] = \"UNDEFINED\";\n    State[State[\"HIDDEN\"] = 254] = \"HIDDEN\";\n    State[State[\"HIGHLIGHTED\"] = 253] = \"HIGHLIGHTED\";\n    State[State[\"XRAYVISIBLE\"] = 252] = \"XRAYVISIBLE\";\n    State[State[\"UNSTYLED\"] = 225] = \"UNSTYLED\";\n})(State = exports.State || (exports.State = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL1ZpZXdlci9zdGF0ZS50cz9kYzQzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICAgICogRW51bWVyYXRpb24gZm9yIG9iamVjdCBzdGF0ZXMuXG4gICAgKiBAcmVhZG9ubHlcbiAgICAqIEBlbnVtIHtudW1iZXJ9XG4gICAgKi9cbmV4cG9ydCBlbnVtIFN0YXRlIHtcbiAgICBVTkRFRklORUQgPSAyNTUsXG4gICAgSElEREVOID0gMjU0LFxuICAgIEhJR0hMSUdIVEVEID0gMjUzLFxuICAgIFhSQVlWSVNJQkxFID0gMjUyLFxuICAgIFVOU1RZTEVEID0gMjI1XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9WaWV3ZXIvc3RhdGUudHMiXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n");

/***/ }),

/***/ 2:
/* no static exports found */
/* all exports used */
/*!********************************!*\
  !*** ./Viewer/product-type.ts ***!
  \********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n* Enumeration of product types.\n* @readonly\n* @enum {number}\n*/\nvar ProductType;\n(function (ProductType) {\n    ProductType[ProductType[\"IFCDISTRIBUTIONELEMENT\"] = 44] = \"IFCDISTRIBUTIONELEMENT\";\n    ProductType[ProductType[\"IFCDISTRIBUTIONFLOWELEMENT\"] = 45] = \"IFCDISTRIBUTIONFLOWELEMENT\";\n    ProductType[ProductType[\"IFCDISTRIBUTIONCHAMBERELEMENT\"] = 180] = \"IFCDISTRIBUTIONCHAMBERELEMENT\";\n    ProductType[ProductType[\"IFCENERGYCONVERSIONDEVICE\"] = 175] = \"IFCENERGYCONVERSIONDEVICE\";\n    ProductType[ProductType[\"IFCAIRTOAIRHEATRECOVERY\"] = 1097] = \"IFCAIRTOAIRHEATRECOVERY\";\n    ProductType[ProductType[\"IFCBOILER\"] = 1105] = \"IFCBOILER\";\n    ProductType[ProductType[\"IFCBURNER\"] = 1109] = \"IFCBURNER\";\n    ProductType[ProductType[\"IFCCHILLER\"] = 1119] = \"IFCCHILLER\";\n    ProductType[ProductType[\"IFCCOIL\"] = 1124] = \"IFCCOIL\";\n    ProductType[ProductType[\"IFCCONDENSER\"] = 1132] = \"IFCCONDENSER\";\n    ProductType[ProductType[\"IFCCOOLEDBEAM\"] = 1141] = \"IFCCOOLEDBEAM\";\n    ProductType[ProductType[\"IFCCOOLINGTOWER\"] = 1142] = \"IFCCOOLINGTOWER\";\n    ProductType[ProductType[\"IFCENGINE\"] = 1164] = \"IFCENGINE\";\n    ProductType[ProductType[\"IFCEVAPORATIVECOOLER\"] = 1166] = \"IFCEVAPORATIVECOOLER\";\n    ProductType[ProductType[\"IFCEVAPORATOR\"] = 1167] = \"IFCEVAPORATOR\";\n    ProductType[ProductType[\"IFCHEATEXCHANGER\"] = 1187] = \"IFCHEATEXCHANGER\";\n    ProductType[ProductType[\"IFCHUMIDIFIER\"] = 1188] = \"IFCHUMIDIFIER\";\n    ProductType[ProductType[\"IFCTUBEBUNDLE\"] = 1305] = \"IFCTUBEBUNDLE\";\n    ProductType[ProductType[\"IFCUNITARYEQUIPMENT\"] = 1310] = \"IFCUNITARYEQUIPMENT\";\n    ProductType[ProductType[\"IFCELECTRICGENERATOR\"] = 1160] = \"IFCELECTRICGENERATOR\";\n    ProductType[ProductType[\"IFCELECTRICMOTOR\"] = 1161] = \"IFCELECTRICMOTOR\";\n    ProductType[ProductType[\"IFCMOTORCONNECTION\"] = 1216] = \"IFCMOTORCONNECTION\";\n    ProductType[ProductType[\"IFCSOLARDEVICE\"] = 1270] = \"IFCSOLARDEVICE\";\n    ProductType[ProductType[\"IFCTRANSFORMER\"] = 1303] = \"IFCTRANSFORMER\";\n    ProductType[ProductType[\"IFCFLOWCONTROLLER\"] = 121] = \"IFCFLOWCONTROLLER\";\n    ProductType[ProductType[\"IFCELECTRICDISTRIBUTIONPOINT\"] = 242] = \"IFCELECTRICDISTRIBUTIONPOINT\";\n    ProductType[ProductType[\"IFCAIRTERMINALBOX\"] = 1096] = \"IFCAIRTERMINALBOX\";\n    ProductType[ProductType[\"IFCDAMPER\"] = 1148] = \"IFCDAMPER\";\n    ProductType[ProductType[\"IFCFLOWMETER\"] = 1182] = \"IFCFLOWMETER\";\n    ProductType[ProductType[\"IFCVALVE\"] = 1311] = \"IFCVALVE\";\n    ProductType[ProductType[\"IFCELECTRICDISTRIBUTIONBOARD\"] = 1157] = \"IFCELECTRICDISTRIBUTIONBOARD\";\n    ProductType[ProductType[\"IFCELECTRICTIMECONTROL\"] = 1162] = \"IFCELECTRICTIMECONTROL\";\n    ProductType[ProductType[\"IFCPROTECTIVEDEVICE\"] = 1235] = \"IFCPROTECTIVEDEVICE\";\n    ProductType[ProductType[\"IFCSWITCHINGDEVICE\"] = 1290] = \"IFCSWITCHINGDEVICE\";\n    ProductType[ProductType[\"IFCFLOWFITTING\"] = 467] = \"IFCFLOWFITTING\";\n    ProductType[ProductType[\"IFCDUCTFITTING\"] = 1153] = \"IFCDUCTFITTING\";\n    ProductType[ProductType[\"IFCPIPEFITTING\"] = 1222] = \"IFCPIPEFITTING\";\n    ProductType[ProductType[\"IFCCABLECARRIERFITTING\"] = 1111] = \"IFCCABLECARRIERFITTING\";\n    ProductType[ProductType[\"IFCCABLEFITTING\"] = 1113] = \"IFCCABLEFITTING\";\n    ProductType[ProductType[\"IFCJUNCTIONBOX\"] = 1195] = \"IFCJUNCTIONBOX\";\n    ProductType[ProductType[\"IFCFLOWMOVINGDEVICE\"] = 502] = \"IFCFLOWMOVINGDEVICE\";\n    ProductType[ProductType[\"IFCCOMPRESSOR\"] = 1131] = \"IFCCOMPRESSOR\";\n    ProductType[ProductType[\"IFCFAN\"] = 1177] = \"IFCFAN\";\n    ProductType[ProductType[\"IFCPUMP\"] = 1238] = \"IFCPUMP\";\n    ProductType[ProductType[\"IFCFLOWSEGMENT\"] = 574] = \"IFCFLOWSEGMENT\";\n    ProductType[ProductType[\"IFCDUCTSEGMENT\"] = 1154] = \"IFCDUCTSEGMENT\";\n    ProductType[ProductType[\"IFCPIPESEGMENT\"] = 1223] = \"IFCPIPESEGMENT\";\n    ProductType[ProductType[\"IFCCABLECARRIERSEGMENT\"] = 1112] = \"IFCCABLECARRIERSEGMENT\";\n    ProductType[ProductType[\"IFCCABLESEGMENT\"] = 1115] = \"IFCCABLESEGMENT\";\n    ProductType[ProductType[\"IFCFLOWSTORAGEDEVICE\"] = 371] = \"IFCFLOWSTORAGEDEVICE\";\n    ProductType[ProductType[\"IFCTANK\"] = 1293] = \"IFCTANK\";\n    ProductType[ProductType[\"IFCELECTRICFLOWSTORAGEDEVICE\"] = 1159] = \"IFCELECTRICFLOWSTORAGEDEVICE\";\n    ProductType[ProductType[\"IFCFLOWTERMINAL\"] = 46] = \"IFCFLOWTERMINAL\";\n    ProductType[ProductType[\"IFCFIRESUPPRESSIONTERMINAL\"] = 1179] = \"IFCFIRESUPPRESSIONTERMINAL\";\n    ProductType[ProductType[\"IFCSANITARYTERMINAL\"] = 1262] = \"IFCSANITARYTERMINAL\";\n    ProductType[ProductType[\"IFCSTACKTERMINAL\"] = 1277] = \"IFCSTACKTERMINAL\";\n    ProductType[ProductType[\"IFCWASTETERMINAL\"] = 1315] = \"IFCWASTETERMINAL\";\n    ProductType[ProductType[\"IFCAIRTERMINAL\"] = 1095] = \"IFCAIRTERMINAL\";\n    ProductType[ProductType[\"IFCMEDICALDEVICE\"] = 1212] = \"IFCMEDICALDEVICE\";\n    ProductType[ProductType[\"IFCSPACEHEATER\"] = 1272] = \"IFCSPACEHEATER\";\n    ProductType[ProductType[\"IFCAUDIOVISUALAPPLIANCE\"] = 1099] = \"IFCAUDIOVISUALAPPLIANCE\";\n    ProductType[ProductType[\"IFCCOMMUNICATIONSAPPLIANCE\"] = 1127] = \"IFCCOMMUNICATIONSAPPLIANCE\";\n    ProductType[ProductType[\"IFCELECTRICAPPLIANCE\"] = 1156] = \"IFCELECTRICAPPLIANCE\";\n    ProductType[ProductType[\"IFCLAMP\"] = 1198] = \"IFCLAMP\";\n    ProductType[ProductType[\"IFCLIGHTFIXTURE\"] = 1199] = \"IFCLIGHTFIXTURE\";\n    ProductType[ProductType[\"IFCOUTLET\"] = 1219] = \"IFCOUTLET\";\n    ProductType[ProductType[\"IFCFLOWTREATMENTDEVICE\"] = 425] = \"IFCFLOWTREATMENTDEVICE\";\n    ProductType[ProductType[\"IFCINTERCEPTOR\"] = 1193] = \"IFCINTERCEPTOR\";\n    ProductType[ProductType[\"IFCDUCTSILENCER\"] = 1155] = \"IFCDUCTSILENCER\";\n    ProductType[ProductType[\"IFCFILTER\"] = 1178] = \"IFCFILTER\";\n    ProductType[ProductType[\"IFCDISTRIBUTIONCONTROLELEMENT\"] = 468] = \"IFCDISTRIBUTIONCONTROLELEMENT\";\n    ProductType[ProductType[\"IFCPROTECTIVEDEVICETRIPPINGUNIT\"] = 1236] = \"IFCPROTECTIVEDEVICETRIPPINGUNIT\";\n    ProductType[ProductType[\"IFCACTUATOR\"] = 1091] = \"IFCACTUATOR\";\n    ProductType[ProductType[\"IFCALARM\"] = 1098] = \"IFCALARM\";\n    ProductType[ProductType[\"IFCCONTROLLER\"] = 1139] = \"IFCCONTROLLER\";\n    ProductType[ProductType[\"IFCFLOWINSTRUMENT\"] = 1181] = \"IFCFLOWINSTRUMENT\";\n    ProductType[ProductType[\"IFCSENSOR\"] = 1264] = \"IFCSENSOR\";\n    ProductType[ProductType[\"IFCUNITARYCONTROLELEMENT\"] = 1308] = \"IFCUNITARYCONTROLELEMENT\";\n    ProductType[ProductType[\"IFCDISCRETEACCESSORY\"] = 423] = \"IFCDISCRETEACCESSORY\";\n    ProductType[ProductType[\"IFCFASTENER\"] = 535] = \"IFCFASTENER\";\n    ProductType[ProductType[\"IFCMECHANICALFASTENER\"] = 536] = \"IFCMECHANICALFASTENER\";\n    ProductType[ProductType[\"IFCREINFORCINGBAR\"] = 571] = \"IFCREINFORCINGBAR\";\n    ProductType[ProductType[\"IFCREINFORCINGMESH\"] = 531] = \"IFCREINFORCINGMESH\";\n    ProductType[ProductType[\"IFCTENDON\"] = 261] = \"IFCTENDON\";\n    ProductType[ProductType[\"IFCTENDONANCHOR\"] = 675] = \"IFCTENDONANCHOR\";\n    ProductType[ProductType[\"IFCBUILDINGELEMENTPART\"] = 220] = \"IFCBUILDINGELEMENTPART\";\n    ProductType[ProductType[\"IFCVIBRATIONISOLATOR\"] = 1312] = \"IFCVIBRATIONISOLATOR\";\n    ProductType[ProductType[\"IFCCHAMFEREDGEFEATURE\"] = 765] = \"IFCCHAMFEREDGEFEATURE\";\n    ProductType[ProductType[\"IFCROUNDEDEDGEFEATURE\"] = 766] = \"IFCROUNDEDEDGEFEATURE\";\n    ProductType[ProductType[\"IFCOPENINGELEMENT\"] = 498] = \"IFCOPENINGELEMENT\";\n    ProductType[ProductType[\"IFCOPENINGSTANDARDCASE\"] = 1217] = \"IFCOPENINGSTANDARDCASE\";\n    ProductType[ProductType[\"IFCVOIDINGFEATURE\"] = 1313] = \"IFCVOIDINGFEATURE\";\n    ProductType[ProductType[\"IFCPROJECTIONELEMENT\"] = 384] = \"IFCPROJECTIONELEMENT\";\n    ProductType[ProductType[\"IFCSURFACEFEATURE\"] = 1287] = \"IFCSURFACEFEATURE\";\n    ProductType[ProductType[\"IFCFOOTING\"] = 120] = \"IFCFOOTING\";\n    ProductType[ProductType[\"IFCPILE\"] = 572] = \"IFCPILE\";\n    ProductType[ProductType[\"IFCBEAM\"] = 171] = \"IFCBEAM\";\n    ProductType[ProductType[\"IFCBEAMSTANDARDCASE\"] = 1104] = \"IFCBEAMSTANDARDCASE\";\n    ProductType[ProductType[\"IFCCOLUMN\"] = 383] = \"IFCCOLUMN\";\n    ProductType[ProductType[\"IFCCOLUMNSTANDARDCASE\"] = 1126] = \"IFCCOLUMNSTANDARDCASE\";\n    ProductType[ProductType[\"IFCCURTAINWALL\"] = 456] = \"IFCCURTAINWALL\";\n    ProductType[ProductType[\"IFCDOOR\"] = 213] = \"IFCDOOR\";\n    ProductType[ProductType[\"IFCDOORSTANDARDCASE\"] = 1151] = \"IFCDOORSTANDARDCASE\";\n    ProductType[ProductType[\"IFCMEMBER\"] = 310] = \"IFCMEMBER\";\n    ProductType[ProductType[\"IFCMEMBERSTANDARDCASE\"] = 1214] = \"IFCMEMBERSTANDARDCASE\";\n    ProductType[ProductType[\"IFCPLATE\"] = 351] = \"IFCPLATE\";\n    ProductType[ProductType[\"IFCPLATESTANDARDCASE\"] = 1224] = \"IFCPLATESTANDARDCASE\";\n    ProductType[ProductType[\"IFCRAILING\"] = 350] = \"IFCRAILING\";\n    ProductType[ProductType[\"IFCRAMP\"] = 414] = \"IFCRAMP\";\n    ProductType[ProductType[\"IFCRAMPFLIGHT\"] = 348] = \"IFCRAMPFLIGHT\";\n    ProductType[ProductType[\"IFCROOF\"] = 347] = \"IFCROOF\";\n    ProductType[ProductType[\"IFCSLAB\"] = 99] = \"IFCSLAB\";\n    ProductType[ProductType[\"IFCSLABELEMENTEDCASE\"] = 1268] = \"IFCSLABELEMENTEDCASE\";\n    ProductType[ProductType[\"IFCSLABSTANDARDCASE\"] = 1269] = \"IFCSLABSTANDARDCASE\";\n    ProductType[ProductType[\"IFCSTAIR\"] = 346] = \"IFCSTAIR\";\n    ProductType[ProductType[\"IFCSTAIRFLIGHT\"] = 25] = \"IFCSTAIRFLIGHT\";\n    ProductType[ProductType[\"IFCWALL\"] = 452] = \"IFCWALL\";\n    ProductType[ProductType[\"IFCWALLSTANDARDCASE\"] = 453] = \"IFCWALLSTANDARDCASE\";\n    ProductType[ProductType[\"IFCWALLELEMENTEDCASE\"] = 1314] = \"IFCWALLELEMENTEDCASE\";\n    ProductType[ProductType[\"IFCWINDOW\"] = 667] = \"IFCWINDOW\";\n    ProductType[ProductType[\"IFCWINDOWSTANDARDCASE\"] = 1316] = \"IFCWINDOWSTANDARDCASE\";\n    ProductType[ProductType[\"IFCBUILDINGELEMENTPROXY\"] = 560] = \"IFCBUILDINGELEMENTPROXY\";\n    ProductType[ProductType[\"IFCCOVERING\"] = 382] = \"IFCCOVERING\";\n    ProductType[ProductType[\"IFCCHIMNEY\"] = 1120] = \"IFCCHIMNEY\";\n    ProductType[ProductType[\"IFCSHADINGDEVICE\"] = 1265] = \"IFCSHADINGDEVICE\";\n    ProductType[ProductType[\"IFCELEMENTASSEMBLY\"] = 18] = \"IFCELEMENTASSEMBLY\";\n    ProductType[ProductType[\"IFCFURNISHINGELEMENT\"] = 253] = \"IFCFURNISHINGELEMENT\";\n    ProductType[ProductType[\"IFCFURNITURE\"] = 1184] = \"IFCFURNITURE\";\n    ProductType[ProductType[\"IFCSYSTEMFURNITUREELEMENT\"] = 1291] = \"IFCSYSTEMFURNITUREELEMENT\";\n    ProductType[ProductType[\"IFCTRANSPORTELEMENT\"] = 416] = \"IFCTRANSPORTELEMENT\";\n    ProductType[ProductType[\"IFCVIRTUALELEMENT\"] = 168] = \"IFCVIRTUALELEMENT\";\n    ProductType[ProductType[\"IFCELECTRICALELEMENT\"] = 23] = \"IFCELECTRICALELEMENT\";\n    ProductType[ProductType[\"IFCEQUIPMENTELEMENT\"] = 212] = \"IFCEQUIPMENTELEMENT\";\n    ProductType[ProductType[\"IFCCIVILELEMENT\"] = 1122] = \"IFCCIVILELEMENT\";\n    ProductType[ProductType[\"IFCGEOGRAPHICELEMENT\"] = 1185] = \"IFCGEOGRAPHICELEMENT\";\n    ProductType[ProductType[\"IFCDISTRIBUTIONPORT\"] = 178] = \"IFCDISTRIBUTIONPORT\";\n    ProductType[ProductType[\"IFCPROXY\"] = 447] = \"IFCPROXY\";\n    ProductType[ProductType[\"IFCSTRUCTURALLINEARACTION\"] = 463] = \"IFCSTRUCTURALLINEARACTION\";\n    ProductType[ProductType[\"IFCSTRUCTURALLINEARACTIONVARYING\"] = 464] = \"IFCSTRUCTURALLINEARACTIONVARYING\";\n    ProductType[ProductType[\"IFCSTRUCTURALPLANARACTION\"] = 39] = \"IFCSTRUCTURALPLANARACTION\";\n    ProductType[ProductType[\"IFCSTRUCTURALPLANARACTIONVARYING\"] = 357] = \"IFCSTRUCTURALPLANARACTIONVARYING\";\n    ProductType[ProductType[\"IFCSTRUCTURALPOINTACTION\"] = 356] = \"IFCSTRUCTURALPOINTACTION\";\n    ProductType[ProductType[\"IFCSTRUCTURALCURVEACTION\"] = 1279] = \"IFCSTRUCTURALCURVEACTION\";\n    ProductType[ProductType[\"IFCSTRUCTURALSURFACEACTION\"] = 1284] = \"IFCSTRUCTURALSURFACEACTION\";\n    ProductType[ProductType[\"IFCSTRUCTURALPOINTREACTION\"] = 354] = \"IFCSTRUCTURALPOINTREACTION\";\n    ProductType[ProductType[\"IFCSTRUCTURALCURVEREACTION\"] = 1280] = \"IFCSTRUCTURALCURVEREACTION\";\n    ProductType[ProductType[\"IFCSTRUCTURALSURFACEREACTION\"] = 1285] = \"IFCSTRUCTURALSURFACEREACTION\";\n    ProductType[ProductType[\"IFCSTRUCTURALCURVECONNECTION\"] = 534] = \"IFCSTRUCTURALCURVECONNECTION\";\n    ProductType[ProductType[\"IFCSTRUCTURALPOINTCONNECTION\"] = 533] = \"IFCSTRUCTURALPOINTCONNECTION\";\n    ProductType[ProductType[\"IFCSTRUCTURALSURFACECONNECTION\"] = 264] = \"IFCSTRUCTURALSURFACECONNECTION\";\n    ProductType[ProductType[\"IFCSTRUCTURALCURVEMEMBER\"] = 224] = \"IFCSTRUCTURALCURVEMEMBER\";\n    ProductType[ProductType[\"IFCSTRUCTURALCURVEMEMBERVARYING\"] = 227] = \"IFCSTRUCTURALCURVEMEMBERVARYING\";\n    ProductType[ProductType[\"IFCSTRUCTURALSURFACEMEMBER\"] = 420] = \"IFCSTRUCTURALSURFACEMEMBER\";\n    ProductType[ProductType[\"IFCSTRUCTURALSURFACEMEMBERVARYING\"] = 421] = \"IFCSTRUCTURALSURFACEMEMBERVARYING\";\n    ProductType[ProductType[\"IFCANNOTATION\"] = 634] = \"IFCANNOTATION\";\n    ProductType[ProductType[\"IFCBUILDING\"] = 169] = \"IFCBUILDING\";\n    ProductType[ProductType[\"IFCBUILDINGSTOREY\"] = 459] = \"IFCBUILDINGSTOREY\";\n    ProductType[ProductType[\"IFCSITE\"] = 349] = \"IFCSITE\";\n    ProductType[ProductType[\"IFCSPACE\"] = 454] = \"IFCSPACE\";\n    ProductType[ProductType[\"IFCGRID\"] = 564] = \"IFCGRID\";\n    ProductType[ProductType[\"IFCEXTERNALSPATIALELEMENT\"] = 1174] = \"IFCEXTERNALSPATIALELEMENT\";\n    ProductType[ProductType[\"IFCSPATIALZONE\"] = 1275] = \"IFCSPATIALZONE\";\n})(ProductType = exports.ProductType || (exports.ProductType = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL1ZpZXdlci9wcm9kdWN0LXR5cGUudHM/ZjM1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiogRW51bWVyYXRpb24gb2YgcHJvZHVjdCB0eXBlcy5cbiogQHJlYWRvbmx5XG4qIEBlbnVtIHtudW1iZXJ9XG4qL1xuZXhwb3J0IGVudW0gUHJvZHVjdFR5cGUge1xuICAgIElGQ0RJU1RSSUJVVElPTkVMRU1FTlQgPSA0NCxcbiAgICBJRkNESVNUUklCVVRJT05GTE9XRUxFTUVOVCA9IDQ1LFxuICAgIElGQ0RJU1RSSUJVVElPTkNIQU1CRVJFTEVNRU5UID0gMTgwLFxuICAgIElGQ0VORVJHWUNPTlZFUlNJT05ERVZJQ0UgPSAxNzUsXG4gICAgSUZDQUlSVE9BSVJIRUFUUkVDT1ZFUlkgPSAxMDk3LFxuICAgIElGQ0JPSUxFUiA9IDExMDUsXG4gICAgSUZDQlVSTkVSID0gMTEwOSxcbiAgICBJRkNDSElMTEVSID0gMTExOSxcbiAgICBJRkNDT0lMID0gMTEyNCxcbiAgICBJRkNDT05ERU5TRVIgPSAxMTMyLFxuICAgIElGQ0NPT0xFREJFQU0gPSAxMTQxLFxuICAgIElGQ0NPT0xJTkdUT1dFUiA9IDExNDIsXG4gICAgSUZDRU5HSU5FID0gMTE2NCxcbiAgICBJRkNFVkFQT1JBVElWRUNPT0xFUiA9IDExNjYsXG4gICAgSUZDRVZBUE9SQVRPUiA9IDExNjcsXG4gICAgSUZDSEVBVEVYQ0hBTkdFUiA9IDExODcsXG4gICAgSUZDSFVNSURJRklFUiA9IDExODgsXG4gICAgSUZDVFVCRUJVTkRMRSA9IDEzMDUsXG4gICAgSUZDVU5JVEFSWUVRVUlQTUVOVCA9IDEzMTAsXG4gICAgSUZDRUxFQ1RSSUNHRU5FUkFUT1IgPSAxMTYwLFxuICAgIElGQ0VMRUNUUklDTU9UT1IgPSAxMTYxLFxuICAgIElGQ01PVE9SQ09OTkVDVElPTiA9IDEyMTYsXG4gICAgSUZDU09MQVJERVZJQ0UgPSAxMjcwLFxuICAgIElGQ1RSQU5TRk9STUVSID0gMTMwMyxcbiAgICBJRkNGTE9XQ09OVFJPTExFUiA9IDEyMSxcbiAgICBJRkNFTEVDVFJJQ0RJU1RSSUJVVElPTlBPSU5UID0gMjQyLFxuICAgIElGQ0FJUlRFUk1JTkFMQk9YID0gMTA5NixcbiAgICBJRkNEQU1QRVIgPSAxMTQ4LFxuICAgIElGQ0ZMT1dNRVRFUiA9IDExODIsXG4gICAgSUZDVkFMVkUgPSAxMzExLFxuICAgIElGQ0VMRUNUUklDRElTVFJJQlVUSU9OQk9BUkQgPSAxMTU3LFxuICAgIElGQ0VMRUNUUklDVElNRUNPTlRST0wgPSAxMTYyLFxuICAgIElGQ1BST1RFQ1RJVkVERVZJQ0UgPSAxMjM1LFxuICAgIElGQ1NXSVRDSElOR0RFVklDRSA9IDEyOTAsXG4gICAgSUZDRkxPV0ZJVFRJTkcgPSA0NjcsXG4gICAgSUZDRFVDVEZJVFRJTkcgPSAxMTUzLFxuICAgIElGQ1BJUEVGSVRUSU5HID0gMTIyMixcbiAgICBJRkNDQUJMRUNBUlJJRVJGSVRUSU5HID0gMTExMSxcbiAgICBJRkNDQUJMRUZJVFRJTkcgPSAxMTEzLFxuICAgIElGQ0pVTkNUSU9OQk9YID0gMTE5NSxcbiAgICBJRkNGTE9XTU9WSU5HREVWSUNFID0gNTAyLFxuICAgIElGQ0NPTVBSRVNTT1IgPSAxMTMxLFxuICAgIElGQ0ZBTiA9IDExNzcsXG4gICAgSUZDUFVNUCA9IDEyMzgsXG4gICAgSUZDRkxPV1NFR01FTlQgPSA1NzQsXG4gICAgSUZDRFVDVFNFR01FTlQgPSAxMTU0LFxuICAgIElGQ1BJUEVTRUdNRU5UID0gMTIyMyxcbiAgICBJRkNDQUJMRUNBUlJJRVJTRUdNRU5UID0gMTExMixcbiAgICBJRkNDQUJMRVNFR01FTlQgPSAxMTE1LFxuICAgIElGQ0ZMT1dTVE9SQUdFREVWSUNFID0gMzcxLFxuICAgIElGQ1RBTksgPSAxMjkzLFxuICAgIElGQ0VMRUNUUklDRkxPV1NUT1JBR0VERVZJQ0UgPSAxMTU5LFxuICAgIElGQ0ZMT1dURVJNSU5BTCA9IDQ2LFxuICAgIElGQ0ZJUkVTVVBQUkVTU0lPTlRFUk1JTkFMID0gMTE3OSxcbiAgICBJRkNTQU5JVEFSWVRFUk1JTkFMID0gMTI2MixcbiAgICBJRkNTVEFDS1RFUk1JTkFMID0gMTI3NyxcbiAgICBJRkNXQVNURVRFUk1JTkFMID0gMTMxNSxcbiAgICBJRkNBSVJURVJNSU5BTCA9IDEwOTUsXG4gICAgSUZDTUVESUNBTERFVklDRSA9IDEyMTIsXG4gICAgSUZDU1BBQ0VIRUFURVIgPSAxMjcyLFxuICAgIElGQ0FVRElPVklTVUFMQVBQTElBTkNFID0gMTA5OSxcbiAgICBJRkNDT01NVU5JQ0FUSU9OU0FQUExJQU5DRSA9IDExMjcsXG4gICAgSUZDRUxFQ1RSSUNBUFBMSUFOQ0UgPSAxMTU2LFxuICAgIElGQ0xBTVAgPSAxMTk4LFxuICAgIElGQ0xJR0hURklYVFVSRSA9IDExOTksXG4gICAgSUZDT1VUTEVUID0gMTIxOSxcbiAgICBJRkNGTE9XVFJFQVRNRU5UREVWSUNFID0gNDI1LFxuICAgIElGQ0lOVEVSQ0VQVE9SID0gMTE5MyxcbiAgICBJRkNEVUNUU0lMRU5DRVIgPSAxMTU1LFxuICAgIElGQ0ZJTFRFUiA9IDExNzgsXG4gICAgSUZDRElTVFJJQlVUSU9OQ09OVFJPTEVMRU1FTlQgPSA0NjgsXG4gICAgSUZDUFJPVEVDVElWRURFVklDRVRSSVBQSU5HVU5JVCA9IDEyMzYsXG4gICAgSUZDQUNUVUFUT1IgPSAxMDkxLFxuICAgIElGQ0FMQVJNID0gMTA5OCxcbiAgICBJRkNDT05UUk9MTEVSID0gMTEzOSxcbiAgICBJRkNGTE9XSU5TVFJVTUVOVCA9IDExODEsXG4gICAgSUZDU0VOU09SID0gMTI2NCxcbiAgICBJRkNVTklUQVJZQ09OVFJPTEVMRU1FTlQgPSAxMzA4LFxuICAgIElGQ0RJU0NSRVRFQUNDRVNTT1JZID0gNDIzLFxuICAgIElGQ0ZBU1RFTkVSID0gNTM1LFxuICAgIElGQ01FQ0hBTklDQUxGQVNURU5FUiA9IDUzNixcbiAgICBJRkNSRUlORk9SQ0lOR0JBUiA9IDU3MSxcbiAgICBJRkNSRUlORk9SQ0lOR01FU0ggPSA1MzEsXG4gICAgSUZDVEVORE9OID0gMjYxLFxuICAgIElGQ1RFTkRPTkFOQ0hPUiA9IDY3NSxcbiAgICBJRkNCVUlMRElOR0VMRU1FTlRQQVJUID0gMjIwLFxuICAgIElGQ1ZJQlJBVElPTklTT0xBVE9SID0gMTMxMixcbiAgICBJRkNDSEFNRkVSRURHRUZFQVRVUkUgPSA3NjUsXG4gICAgSUZDUk9VTkRFREVER0VGRUFUVVJFID0gNzY2LFxuICAgIElGQ09QRU5JTkdFTEVNRU5UID0gNDk4LFxuICAgIElGQ09QRU5JTkdTVEFOREFSRENBU0UgPSAxMjE3LFxuICAgIElGQ1ZPSURJTkdGRUFUVVJFID0gMTMxMyxcbiAgICBJRkNQUk9KRUNUSU9ORUxFTUVOVCA9IDM4NCxcbiAgICBJRkNTVVJGQUNFRkVBVFVSRSA9IDEyODcsXG4gICAgSUZDRk9PVElORyA9IDEyMCxcbiAgICBJRkNQSUxFID0gNTcyLFxuICAgIElGQ0JFQU0gPSAxNzEsXG4gICAgSUZDQkVBTVNUQU5EQVJEQ0FTRSA9IDExMDQsXG4gICAgSUZDQ09MVU1OID0gMzgzLFxuICAgIElGQ0NPTFVNTlNUQU5EQVJEQ0FTRSA9IDExMjYsXG4gICAgSUZDQ1VSVEFJTldBTEwgPSA0NTYsXG4gICAgSUZDRE9PUiA9IDIxMyxcbiAgICBJRkNET09SU1RBTkRBUkRDQVNFID0gMTE1MSxcbiAgICBJRkNNRU1CRVIgPSAzMTAsXG4gICAgSUZDTUVNQkVSU1RBTkRBUkRDQVNFID0gMTIxNCxcbiAgICBJRkNQTEFURSA9IDM1MSxcbiAgICBJRkNQTEFURVNUQU5EQVJEQ0FTRSA9IDEyMjQsXG4gICAgSUZDUkFJTElORyA9IDM1MCxcbiAgICBJRkNSQU1QID0gNDE0LFxuICAgIElGQ1JBTVBGTElHSFQgPSAzNDgsXG4gICAgSUZDUk9PRiA9IDM0NyxcbiAgICBJRkNTTEFCID0gOTksXG4gICAgSUZDU0xBQkVMRU1FTlRFRENBU0UgPSAxMjY4LFxuICAgIElGQ1NMQUJTVEFOREFSRENBU0UgPSAxMjY5LFxuICAgIElGQ1NUQUlSID0gMzQ2LFxuICAgIElGQ1NUQUlSRkxJR0hUID0gMjUsXG4gICAgSUZDV0FMTCA9IDQ1MixcbiAgICBJRkNXQUxMU1RBTkRBUkRDQVNFID0gNDUzLFxuICAgIElGQ1dBTExFTEVNRU5URURDQVNFID0gMTMxNCxcbiAgICBJRkNXSU5ET1cgPSA2NjcsXG4gICAgSUZDV0lORE9XU1RBTkRBUkRDQVNFID0gMTMxNixcbiAgICBJRkNCVUlMRElOR0VMRU1FTlRQUk9YWSA9IDU2MCxcbiAgICBJRkNDT1ZFUklORyA9IDM4MixcbiAgICBJRkNDSElNTkVZID0gMTEyMCxcbiAgICBJRkNTSEFESU5HREVWSUNFID0gMTI2NSxcbiAgICBJRkNFTEVNRU5UQVNTRU1CTFkgPSAxOCxcbiAgICBJRkNGVVJOSVNISU5HRUxFTUVOVCA9IDI1MyxcbiAgICBJRkNGVVJOSVRVUkUgPSAxMTg0LFxuICAgIElGQ1NZU1RFTUZVUk5JVFVSRUVMRU1FTlQgPSAxMjkxLFxuICAgIElGQ1RSQU5TUE9SVEVMRU1FTlQgPSA0MTYsXG4gICAgSUZDVklSVFVBTEVMRU1FTlQgPSAxNjgsXG4gICAgSUZDRUxFQ1RSSUNBTEVMRU1FTlQgPSAyMyxcbiAgICBJRkNFUVVJUE1FTlRFTEVNRU5UID0gMjEyLFxuICAgIElGQ0NJVklMRUxFTUVOVCA9IDExMjIsXG4gICAgSUZDR0VPR1JBUEhJQ0VMRU1FTlQgPSAxMTg1LFxuICAgIElGQ0RJU1RSSUJVVElPTlBPUlQgPSAxNzgsXG4gICAgSUZDUFJPWFkgPSA0NDcsXG4gICAgSUZDU1RSVUNUVVJBTExJTkVBUkFDVElPTiA9IDQ2MyxcbiAgICBJRkNTVFJVQ1RVUkFMTElORUFSQUNUSU9OVkFSWUlORyA9IDQ2NCxcbiAgICBJRkNTVFJVQ1RVUkFMUExBTkFSQUNUSU9OID0gMzksXG4gICAgSUZDU1RSVUNUVVJBTFBMQU5BUkFDVElPTlZBUllJTkcgPSAzNTcsXG4gICAgSUZDU1RSVUNUVVJBTFBPSU5UQUNUSU9OID0gMzU2LFxuICAgIElGQ1NUUlVDVFVSQUxDVVJWRUFDVElPTiA9IDEyNzksXG4gICAgSUZDU1RSVUNUVVJBTFNVUkZBQ0VBQ1RJT04gPSAxMjg0LFxuICAgIElGQ1NUUlVDVFVSQUxQT0lOVFJFQUNUSU9OID0gMzU0LFxuICAgIElGQ1NUUlVDVFVSQUxDVVJWRVJFQUNUSU9OID0gMTI4MCxcbiAgICBJRkNTVFJVQ1RVUkFMU1VSRkFDRVJFQUNUSU9OID0gMTI4NSxcbiAgICBJRkNTVFJVQ1RVUkFMQ1VSVkVDT05ORUNUSU9OID0gNTM0LFxuICAgIElGQ1NUUlVDVFVSQUxQT0lOVENPTk5FQ1RJT04gPSA1MzMsXG4gICAgSUZDU1RSVUNUVVJBTFNVUkZBQ0VDT05ORUNUSU9OID0gMjY0LFxuICAgIElGQ1NUUlVDVFVSQUxDVVJWRU1FTUJFUiA9IDIyNCxcbiAgICBJRkNTVFJVQ1RVUkFMQ1VSVkVNRU1CRVJWQVJZSU5HID0gMjI3LFxuICAgIElGQ1NUUlVDVFVSQUxTVVJGQUNFTUVNQkVSID0gNDIwLFxuICAgIElGQ1NUUlVDVFVSQUxTVVJGQUNFTUVNQkVSVkFSWUlORyA9IDQyMSxcbiAgICBJRkNBTk5PVEFUSU9OID0gNjM0LFxuICAgIElGQ0JVSUxESU5HID0gMTY5LFxuICAgIElGQ0JVSUxESU5HU1RPUkVZID0gNDU5LFxuICAgIElGQ1NJVEUgPSAzNDksXG4gICAgSUZDU1BBQ0UgPSA0NTQsXG4gICAgSUZDR1JJRCA9IDU2NCxcbiAgICBJRkNFWFRFUk5BTFNQQVRJQUxFTEVNRU5UID0gMTE3NCxcbiAgICBJRkNTUEFUSUFMWk9ORSA9IDEyNzVcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL1ZpZXdlci9wcm9kdWN0LXR5cGUudHMiXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n");

/***/ }),

/***/ 29:
/* no static exports found */
/* all exports used */
/*!***********************************************!*\
  !*** ./Viewer/workers/geometry-loader-new.ts ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar model_geometry_1 = __webpack_require__(/*! ../model-geometry */ 3);\n//only run following script if this is created as a Worker\nif (self && self instanceof DedicatedWorkerGlobalScope) {\n    var worker = self;\n    worker.onmessage = function (e) {\n        var model = e.data;\n        var geometry = new model_geometry_1.ModelGeometry();\n        geometry.onerror = function (msg) {\n            throw msg;\n        };\n        geometry.onloaded = function () {\n            try {\n                var msg = {};\n                var transferable = [];\n                for (var i in geometry) {\n                    if (!geometry.hasOwnProperty(i))\n                        continue;\n                    var prop = geometry[i];\n                    if (typeof prop === \"function\")\n                        continue;\n                    //building message object containing values but no functions or anything\n                    msg[i] = prop;\n                    //create array of transferable objects for all typed arrays. Browsers which support Transferable interface will speed this up massively\n                    if (ArrayBuffer.isView(prop))\n                        transferable.push(prop.buffer);\n                }\n                //post the object and pass through all transferable objects\n                worker.postMessage(msg, transferable);\n                worker.close();\n            }\n            catch (e) {\n                worker.close();\n                throw e;\n            }\n        };\n        geometry.loadNew(model);\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9WaWV3ZXIvd29ya2Vycy9nZW9tZXRyeS1sb2FkZXItbmV3LnRzPzRiMTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTW9kZWxHZW9tZXRyeSB9IGZyb20gXCIuLi9tb2RlbC1nZW9tZXRyeVwiO1xuXG4vL29ubHkgcnVuIGZvbGxvd2luZyBzY3JpcHQgaWYgdGhpcyBpcyBjcmVhdGVkIGFzIGEgV29ya2VyXG5pZiAoc2VsZiAmJiBzZWxmIGluc3RhbmNlb2YgRGVkaWNhdGVkV29ya2VyR2xvYmFsU2NvcGUgKSB7XG4gICAgdmFyIHdvcmtlciA9IHNlbGYgYXMgRGVkaWNhdGVkV29ya2VyR2xvYmFsU2NvcGU7XG4gICAgd29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBtb2RlbCA9IGUuZGF0YTtcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gbmV3IE1vZGVsR2VvbWV0cnkoKTtcblxuICAgICAgICBnZW9tZXRyeS5vbmVycm9yID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICAgICAgdGhyb3cgbXNnO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2VvbWV0cnkub25sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBtc2cgPSB7fTtcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNmZXJhYmxlID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBnZW9tZXRyeSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWdlb21ldHJ5Lmhhc093blByb3BlcnR5KGkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWVcblxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcCA9IGdlb21ldHJ5W2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vYnVpbGRpbmcgbWVzc2FnZSBvYmplY3QgY29udGFpbmluZyB2YWx1ZXMgYnV0IG5vIGZ1bmN0aW9ucyBvciBhbnl0aGluZ1xuICAgICAgICAgICAgICAgICAgICBtc2dbaV0gPSBwcm9wXG5cbiAgICAgICAgICAgICAgICAgICAgLy9jcmVhdGUgYXJyYXkgb2YgdHJhbnNmZXJhYmxlIG9iamVjdHMgZm9yIGFsbCB0eXBlZCBhcnJheXMuIEJyb3dzZXJzIHdoaWNoIHN1cHBvcnQgVHJhbnNmZXJhYmxlIGludGVyZmFjZSB3aWxsIHNwZWVkIHRoaXMgdXAgbWFzc2l2ZWx5XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcocHJvcCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2ZlcmFibGUucHVzaChwcm9wLmJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9wb3N0IHRoZSBvYmplY3QgYW5kIHBhc3MgdGhyb3VnaCBhbGwgdHJhbnNmZXJhYmxlIG9iamVjdHNcbiAgICAgICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2UobXNnLCB0cmFuc2ZlcmFibGUpO1xuICAgICAgICAgICAgICAgIHdvcmtlci5jbG9zZSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHdvcmtlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGdlb21ldHJ5LmxvYWROZXcobW9kZWwpO1xuICAgIH07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9WaWV3ZXIvd29ya2Vycy9nZW9tZXRyeS1sb2FkZXItbmV3LnRzIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///29\n");

/***/ }),

/***/ 3:
/* no static exports found */
/* all exports used */
/*!**********************************!*\
  !*** ./Viewer/model-geometry.ts ***!
  \**********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar binary_reader_1 = __webpack_require__(/*! ./binary-reader */ 4);\nvar triangulated_shape_1 = __webpack_require__(/*! ./triangulated-shape */ 8);\nvar state_1 = __webpack_require__(/*! ./state */ 0);\nvar product_type_1 = __webpack_require__(/*! ./product-type */ 2);\nvar ModelGeometry = (function () {\n    function ModelGeometry() {\n        this.meter = 1000;\n        //this will be used to change appearance of the objects\n        //map objects have a format:\n        //map = {\n        //\tproductID: int,\n        //\ttype: int,\n        //\tbBox: Float32Array(6),\n        //\tspans: [Int32Array([int, int]),Int32Array([int, int]), ...] //spanning indexes defining shapes of product and it's state\n        //};\n        this.productMaps = {};\n    }\n    ModelGeometry.prototype.parseNew = function (binReader) {\n        var _this = this;\n        var br = binReader;\n        var magicNumber = br.readInt32();\n        if (magicNumber != 94132117)\n            throw 'Magic number mismatch.';\n        var version = br.readByte();\n        var numShapes = br.readInt32();\n        var numVertices = br.readInt32();\n        var numTriangles = br.readInt32();\n        var numMatrices = br.readInt32();\n        ;\n        var numProducts = br.readInt32();\n        ;\n        var numStyles = br.readInt32();\n        ;\n        this.meter = br.readFloat32();\n        ;\n        var numRegions = br.readInt16();\n        //set size of arrays to be square usable for texture data\n        //TODO: reflect support for floating point textures\n        var square = function (arity, count) {\n            if (typeof (arity) == 'undefined' || typeof (count) == 'undefined') {\n                throw 'Wrong arguments';\n            }\n            if (count == 0)\n                return 0;\n            var byteLength = count * arity;\n            var imgSide = Math.ceil(Math.sqrt(byteLength / 4));\n            //clamp to parity\n            while ((imgSide * 4) % arity != 0) {\n                imgSide++;\n            }\n            var result = imgSide * imgSide * 4 / arity;\n            return result;\n        };\n        //create target buffers of correct size (avoid reallocation of memory)\n        this.vertices = new Float32Array(square(4, numVertices * 3));\n        this.normals = new Uint8Array(numTriangles * 6);\n        this.indices = new Float32Array(numTriangles * 3);\n        this.styleIndices = new Uint16Array(numTriangles * 3);\n        this.styles = new Uint8Array(square(1, (numStyles + 1) * 4)); //+1 is for a default style\n        this.products = new Float32Array(numTriangles * 3);\n        this.states = new Uint8Array(numTriangles * 3 * 2); //place for state and restyling\n        this.transformations = new Float32Array(numTriangles * 3);\n        this.matrices = new Float32Array(square(4, numMatrices * 16));\n        this.productMaps = {};\n        this.regions = new Array(numRegions);\n        var iVertex = 0;\n        var iIndexForward = 0;\n        var iIndexBackward = numTriangles * 3;\n        var iTransform = 0;\n        var iMatrix = 0;\n        var stateEnum = state_1.State;\n        var typeEnum = product_type_1.ProductType;\n        for (var i = 0; i < numRegions; i++) {\n            var region = new Region();\n            region.population = br.readInt32();\n            region.centre = br.readFloat32Array(3);\n            region.bbox = br.readFloat32Array(6);\n            this.regions[i] = region;\n        }\n        var styleMap = [];\n        styleMap['getStyle'] = function (id) {\n            for (var i = 0; i < this.length; i++) {\n                var item = this[i];\n                if (item.id == id)\n                    return item;\n            }\n            return null;\n        };\n        var iStyle = 0;\n        for (iStyle; iStyle < numStyles; iStyle++) {\n            var styleId = br.readInt32();\n            var R = br.readFloat32() * 255;\n            var G = br.readFloat32() * 255;\n            var B = br.readFloat32() * 255;\n            var A = br.readFloat32() * 255;\n            this.styles.set([R, G, B, A], iStyle * 4);\n            styleMap.push({ id: styleId, index: iStyle, transparent: A < 254 });\n        }\n        this.styles.set([255, 255, 255, 255], iStyle * 4);\n        var defaultStyle = { id: -1, index: iStyle, transparent: A < 254 };\n        styleMap.push(defaultStyle);\n        for (var i = 0; i < numProducts; i++) {\n            var productLabel = br.readInt32();\n            var prodType = br.readInt16();\n            var bBox = br.readFloat32Array(6);\n            var map = {\n                productID: productLabel,\n                type: prodType,\n                bBox: bBox,\n                spans: []\n            };\n            this.productMaps[productLabel] = map;\n        }\n        for (var iShape = 0; iShape < numShapes; iShape++) {\n            var repetition = br.readInt32();\n            var shapeList = [];\n            for (var iProduct = 0; iProduct < repetition; iProduct++) {\n                var prodLabel = br.readInt32();\n                var instanceTypeId = br.readInt16();\n                var instanceLabel = br.readInt32();\n                var styleId = br.readInt32();\n                var transformation = null;\n                // if (repetition > 1) {\n                transformation = version === 1 ? br.readFloat32Array(16) : br.readFloat64Array(16);\n                this.matrices.set(transformation, iMatrix);\n                iMatrix += 16;\n                // }\n                // read out transformation num trangles\n                br.readInt32();\n                var styleItem = styleMap['getStyle'](styleId);\n                if (styleItem === null)\n                    styleItem = defaultStyle;\n                shapeList.push({\n                    pLabel: prodLabel,\n                    iLabel: instanceLabel,\n                    style: styleItem.index,\n                    transparent: styleItem.transparent,\n                    transform: transformation != null ? iTransform++ : -1\n                });\n            }\n            //read shape geometry\n            var shapeGeom = new triangulated_shape_1.TriangulatedShape();\n            // read out geometry num vertices\n            br.readInt32();\n            // read out length\n            br.readInt32();\n            shapeGeom.parse(br);\n            //copy shape data into inner array and set to null so it can be garbage collected\n            shapeList.forEach(function (shape) {\n                var iIndex = 0;\n                //set iIndex according to transparency either from beginning or at the end\n                if (shape.transparent) {\n                    iIndex = iIndexBackward - shapeGeom.indices.length;\n                }\n                else {\n                    iIndex = iIndexForward;\n                }\n                var begin = iIndex;\n                var map = _this.productMaps[shape.pLabel];\n                if (typeof (map) === \"undefined\") {\n                    //throw \"Product hasn't been defined before.\";\n                    map = {\n                        productID: 0,\n                        type: typeEnum.IFCOPENINGELEMENT,\n                        bBox: new Float32Array(6),\n                        spans: []\n                    };\n                    _this.productMaps[shape.pLabel] = map;\n                }\n                _this.normals.set(shapeGeom.normals, iIndex * 2);\n                //switch spaces and openings off by default\n                var state = map.type == typeEnum.IFCSPACE || map.type == typeEnum.IFCOPENINGELEMENT\n                    ? stateEnum.HIDDEN\n                    : 0xFF; //0xFF is for the default state\n                //fix indices to right absolute position. It is relative to the shape.\n                for (var i = 0; i < shapeGeom.indices.length; i++) {\n                    _this.indices[iIndex] = shapeGeom.indices[i] + iVertex / 3;\n                    _this.products[iIndex] = shape.pLabel;\n                    _this.styleIndices[iIndex] = shape.style;\n                    _this.transformations[iIndex] = shape.transform;\n                    _this.states[2 * iIndex] = state; //set state\n                    _this.states[2 * iIndex + 1] = 0xFF; //default style\n                    iIndex++;\n                }\n                var end = iIndex;\n                map.spans.push(new Int32Array([begin, end]));\n                if (shape.transparent)\n                    iIndexBackward -= shapeGeom.indices.length;\n                else\n                    iIndexForward += shapeGeom.indices.length;\n            }, this);\n            //copy geometry and keep track of amount so that we can fix indices to right position\n            //this must be the last step to have correct iVertex number above\n            this.vertices.set(shapeGeom.vertices, iVertex);\n            iVertex += shapeGeom.vertices.length;\n            shapeGeom = null;\n        }\n        //binary reader should be at the end by now\n        if (!br.isEOF()) {\n            //throw 'Binary reader is not at the end of the file.';\n        }\n        this.transparentIndex = iIndexForward;\n    };\n    //Source has to be either URL of wexBIM file or Blob representing wexBIM file\n    ModelGeometry.prototype.loadNew = function (source) {\n        //binary reading\n        var br = new binary_reader_1.BinaryReader();\n        var self = this;\n        br.onloaded = function () {\n            self.parseNew(br);\n            if (self.onloaded) {\n                self.onloaded(this);\n            }\n        };\n        br.onerror = function (msg) {\n            if (self.onerror)\n                self.onerror(msg);\n        };\n        br.load(source);\n    };\n    ModelGeometry.prototype.parse = function (binReader) {\n        var _this = this;\n        var br = binReader;\n        var magicNumber = br.readInt32();\n        if (magicNumber != 94132117)\n            throw 'Magic number mismatch.';\n        var version = br.readByte();\n        var numShapes = br.readInt32();\n        var numVertices = br.readInt32();\n        var numTriangles = br.readInt32();\n        var numMatrices = br.readInt32();\n        ;\n        var numProducts = br.readInt32();\n        ;\n        var numStyles = br.readInt32();\n        ;\n        this.meter = br.readFloat32();\n        ;\n        var numRegions = br.readInt16();\n        //set size of arrays to be square usable for texture data\n        //TODO: reflect support for floating point textures\n        var square = function (arity, count) {\n            if (typeof (arity) == 'undefined' || typeof (count) == 'undefined') {\n                throw 'Wrong arguments';\n            }\n            if (count == 0)\n                return 0;\n            var byteLength = count * arity;\n            var imgSide = Math.ceil(Math.sqrt(byteLength / 4));\n            //clamp to parity\n            while ((imgSide * 4) % arity != 0) {\n                imgSide++;\n            }\n            var result = imgSide * imgSide * 4 / arity;\n            return result;\n        };\n        //create target buffers of correct size (avoid reallocation of memory)\n        this.vertices = new Float32Array(square(4, numVertices * 3));\n        this.normals = new Uint8Array(numTriangles * 6);\n        this.indices = new Float32Array(numTriangles * 3);\n        this.styleIndices = new Uint16Array(numTriangles * 3);\n        this.styles = new Uint8Array(square(1, (numStyles + 1) * 4)); //+1 is for a default style\n        this.products = new Float32Array(numTriangles * 3);\n        this.states = new Uint8Array(numTriangles * 3 * 2); //place for state and restyling\n        this.transformations = new Float32Array(numTriangles * 3);\n        this.matrices = new Float32Array(square(4, numMatrices * 16));\n        this.productMaps = {};\n        this.regions = new Array(numRegions);\n        var iVertex = 0;\n        var iIndexForward = 0;\n        var iIndexBackward = numTriangles * 3;\n        var iTransform = 0;\n        var iMatrix = 0;\n        var stateEnum = state_1.State;\n        var typeEnum = product_type_1.ProductType;\n        for (var i = 0; i < numRegions; i++) {\n            var region = new Region();\n            region.population = br.readInt32();\n            region.centre = br.readFloat32Array(3);\n            region.bbox = br.readFloat32Array(6);\n            this.regions[i] = region;\n        }\n        var styleMap = [];\n        styleMap['getStyle'] = function (id) {\n            for (var i = 0; i < this.length; i++) {\n                var item = this[i];\n                if (item.id == id)\n                    return item;\n            }\n            return null;\n        };\n        var iStyle = 0;\n        for (iStyle; iStyle < numStyles; iStyle++) {\n            var styleId = br.readInt32();\n            var R = br.readFloat32() * 255;\n            var G = br.readFloat32() * 255;\n            var B = br.readFloat32() * 255;\n            var A = br.readFloat32() * 255;\n            this.styles.set([R, G, B, A], iStyle * 4);\n            styleMap.push({ id: styleId, index: iStyle, transparent: A < 254 });\n        }\n        this.styles.set([255, 255, 255, 255], iStyle * 4);\n        var defaultStyle = { id: -1, index: iStyle, transparent: A < 254 };\n        styleMap.push(defaultStyle);\n        for (var i = 0; i < numProducts; i++) {\n            var productLabel = br.readInt32();\n            var prodType = br.readInt16();\n            var bBox = br.readFloat32Array(6);\n            var map = {\n                productID: productLabel,\n                type: prodType,\n                bBox: bBox,\n                spans: []\n            };\n            this.productMaps[productLabel] = map;\n        }\n        for (var iShape = 0; iShape < numShapes; iShape++) {\n            var repetition = br.readInt32();\n            var shapeList = [];\n            for (var iProduct = 0; iProduct < repetition; iProduct++) {\n                var prodLabel = br.readInt32();\n                var instanceTypeId = br.readInt16();\n                var instanceLabel = br.readInt32();\n                var styleId = br.readInt32();\n                var transformation = null;\n                if (repetition > 1) {\n                    transformation = version === 1 ? br.readFloat32Array(16) : br.readFloat64Array(16);\n                    this.matrices.set(transformation, iMatrix);\n                    iMatrix += 16;\n                }\n                var styleItem = styleMap['getStyle'](styleId);\n                if (styleItem === null)\n                    styleItem = defaultStyle;\n                shapeList.push({\n                    pLabel: prodLabel,\n                    iLabel: instanceLabel,\n                    style: styleItem.index,\n                    transparent: styleItem.transparent,\n                    transform: transformation != null ? iTransform++ : -1\n                });\n            }\n            //read shape geometry\n            var shapeGeom = new triangulated_shape_1.TriangulatedShape();\n            shapeGeom.parse(br);\n            //copy shape data into inner array and set to null so it can be garbage collected\n            shapeList.forEach(function (shape) {\n                var iIndex = 0;\n                //set iIndex according to transparency either from beginning or at the end\n                if (shape.transparent) {\n                    iIndex = iIndexBackward - shapeGeom.indices.length;\n                }\n                else {\n                    iIndex = iIndexForward;\n                }\n                var begin = iIndex;\n                var map = _this.productMaps[shape.pLabel];\n                if (typeof (map) === \"undefined\") {\n                    //throw \"Product hasn't been defined before.\";\n                    map = {\n                        productID: 0,\n                        type: typeEnum.IFCOPENINGELEMENT,\n                        bBox: new Float32Array(6),\n                        spans: []\n                    };\n                    _this.productMaps[shape.pLabel] = map;\n                }\n                _this.normals.set(shapeGeom.normals, iIndex * 2);\n                //switch spaces and openings off by default\n                var state = map.type == typeEnum.IFCSPACE || map.type == typeEnum.IFCOPENINGELEMENT\n                    ? stateEnum.HIDDEN\n                    : 0xFF; //0xFF is for the default state\n                //fix indices to right absolute position. It is relative to the shape.\n                for (var i = 0; i < shapeGeom.indices.length; i++) {\n                    _this.indices[iIndex] = shapeGeom.indices[i] + iVertex / 3;\n                    _this.products[iIndex] = shape.pLabel;\n                    _this.styleIndices[iIndex] = shape.style;\n                    _this.transformations[iIndex] = shape.transform;\n                    _this.states[2 * iIndex] = state; //set state\n                    _this.states[2 * iIndex + 1] = 0xFF; //default style\n                    iIndex++;\n                }\n                var end = iIndex;\n                map.spans.push(new Int32Array([begin, end]));\n                if (shape.transparent)\n                    iIndexBackward -= shapeGeom.indices.length;\n                else\n                    iIndexForward += shapeGeom.indices.length;\n            }, this);\n            //copy geometry and keep track of amount so that we can fix indices to right position\n            //this must be the last step to have correct iVertex number above\n            this.vertices.set(shapeGeom.vertices, iVertex);\n            iVertex += shapeGeom.vertices.length;\n            shapeGeom = null;\n        }\n        //binary reader should be at the end by now\n        if (!br.isEOF()) {\n            //throw 'Binary reader is not at the end of the file.';\n        }\n        this.transparentIndex = iIndexForward;\n    };\n    //Source has to be either URL of wexBIM file or Blob representing wexBIM file\n    ModelGeometry.prototype.load = function (source) {\n        //binary reading\n        var br = new binary_reader_1.BinaryReader();\n        var self = this;\n        br.onloaded = function () {\n            self.parse(br);\n            if (self.onloaded) {\n                self.onloaded(this);\n            }\n        };\n        br.onerror = function (msg) {\n            if (self.onerror)\n                self.onerror(msg);\n        };\n        br.load(source);\n    };\n    return ModelGeometry;\n}());\nexports.ModelGeometry = ModelGeometry;\nvar ProductMap = (function () {\n    function ProductMap() {\n    }\n    return ProductMap;\n}());\nexports.ProductMap = ProductMap;\nvar Region = (function () {\n    function Region(region) {\n        this.population = -1;\n        this.centre = null;\n        this.bbox = null;\n        if (region) {\n            this.population = region.population;\n            this.centre = new Float32Array(region.centre);\n            this.bbox = new Float32Array(region.bbox);\n        }\n    }\n    /**\n     * Returns clone of this region\n     */\n    Region.prototype.clone = function () {\n        var clone = new Region();\n        clone.population = this.population;\n        clone.centre = new Float32Array(this.centre);\n        clone.bbox = new Float32Array(this.bbox);\n        return clone;\n    };\n    /**\n     * Returns new region which is a merge of this region and the argument\n     * @param region region to be merged\n     */\n    Region.prototype.merge = function (region) {\n        //if this is a new empty region, return clone of the argument\n        if (this.population === -1 && this.centre === null && this.bbox === null)\n            return new Region(region);\n        var out = new Region();\n        out.population = this.population + region.population;\n        var x = Math.min(this.bbox[0], region.bbox[0]);\n        var y = Math.min(this.bbox[1], region.bbox[1]);\n        var z = Math.min(this.bbox[2], region.bbox[2]);\n        var x2 = Math.min(this.bbox[0] + this.bbox[3], region.bbox[0] + region.bbox[3]);\n        var y2 = Math.min(this.bbox[1] + this.bbox[4], region.bbox[1] + region.bbox[4]);\n        var z2 = Math.min(this.bbox[2] + this.bbox[5], region.bbox[2] + region.bbox[5]);\n        var sx = x2 - x;\n        var sy = y2 - y;\n        var sz = z2 - z;\n        var cx = (x + x2) / 2.0;\n        var cy = (y + y2) / 2.0;\n        var cz = (z + z2) / 2.0;\n        out.bbox = new Float32Array([x, y, z, sx, sy, sz]);\n        out.centre = new Float32Array([cx, cy, cz]);\n        return out;\n    };\n    return Region;\n}());\nexports.Region = Region;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL1ZpZXdlci9tb2RlbC1nZW9tZXRyeS50cz8zNDFlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJpbmFyeVJlYWRlciB9IGZyb20gXCIuL2JpbmFyeS1yZWFkZXJcIjtcbmltcG9ydCB7IFRyaWFuZ3VsYXRlZFNoYXBlIH0gZnJvbSBcIi4vdHJpYW5ndWxhdGVkLXNoYXBlXCI7XG5pbXBvcnQgeyBTdGF0ZSB9IGZyb20gXCIuL3N0YXRlXCI7XG5pbXBvcnQgeyBQcm9kdWN0VHlwZSB9IGZyb20gXCIuL3Byb2R1Y3QtdHlwZVwiO1xuXG5leHBvcnQgY2xhc3MgTW9kZWxHZW9tZXRyeSB7XG4gICAgLy9hbGwgdGhpcyBkYXRhIGlzIHRvIGJlIGZlZCBpbnRvIEdQVSBhcyBhdHRyaWJ1dGVzXG4gICAgbm9ybWFsczogVWludDhBcnJheTtcbiAgICBpbmRpY2VzOiBGbG9hdDMyQXJyYXk7XG4gICAgcHJvZHVjdHM6IEZsb2F0MzJBcnJheTtcbiAgICB0cmFuc2Zvcm1hdGlvbnM6IEZsb2F0MzJBcnJheTtcbiAgICBzdHlsZUluZGljZXM6IFVpbnQxNkFycmF5O1xuICAgIHN0YXRlczogVWludDhBcnJheTtcbiAgICAvL3RoaXMgaXMgdGhlIG9ubHkgYXJyYXkgd2UgbmVlZCB0byBrZWVwIGFsaXZlIG9uIGNsaWVudCBzaWRlIHRvIGJlIGFibGUgdG8gY2hhbmdlIGFwcGVhcmFuY2Ugb2YgdGhlIG1vZGVsXG5cbiAgICAvL3RoZXNlIHdpbGwgYmUgc2VudCB0byBHUFUgYXMgdGhlIHRleHR1cmVzXG4gICAgdmVydGljZXM6IEZsb2F0MzJBcnJheTtcbiAgICBtYXRyaWNlczogRmxvYXQzMkFycmF5O1xuICAgIHN0eWxlczogVWludDhBcnJheTtcblxuICAgIG1ldGVyID0gMTAwMDtcblxuICAgIC8vdGhpcyB3aWxsIGJlIHVzZWQgdG8gY2hhbmdlIGFwcGVhcmFuY2Ugb2YgdGhlIG9iamVjdHNcbiAgICAvL21hcCBvYmplY3RzIGhhdmUgYSBmb3JtYXQ6XG4gICAgLy9tYXAgPSB7XG4gICAgLy9cdHByb2R1Y3RJRDogaW50LFxuICAgIC8vXHR0eXBlOiBpbnQsXG4gICAgLy9cdGJCb3g6IEZsb2F0MzJBcnJheSg2KSxcbiAgICAvL1x0c3BhbnM6IFtJbnQzMkFycmF5KFtpbnQsIGludF0pLEludDMyQXJyYXkoW2ludCwgaW50XSksIC4uLl0gLy9zcGFubmluZyBpbmRleGVzIGRlZmluaW5nIHNoYXBlcyBvZiBwcm9kdWN0IGFuZCBpdCdzIHN0YXRlXG4gICAgLy99O1xuXG4gICAgcHVibGljIHByb2R1Y3RNYXBzOiB7IFtpZDogbnVtYmVyXTogUHJvZHVjdE1hcDsgfSA9IHt9O1xuICAgIHB1YmxpYyByZWdpb25zOiBSZWdpb25bXTtcbiAgICBwdWJsaWMgdHJhbnNwYXJlbnRJbmRleDogbnVtYmVyO1xuXG4gICAgcHVibGljIHBhcnNlTmV3KGJpblJlYWRlcjogQmluYXJ5UmVhZGVyKSB7XG4gICAgICAgIHZhciBiciA9IGJpblJlYWRlcjtcbiAgICAgICAgdmFyIG1hZ2ljTnVtYmVyID0gYnIucmVhZEludDMyKCk7XG4gICAgICAgIGlmIChtYWdpY051bWJlciAhPSA5NDEzMjExNykgdGhyb3cgJ01hZ2ljIG51bWJlciBtaXNtYXRjaC4nO1xuICAgICAgICB2YXIgdmVyc2lvbiA9IGJyLnJlYWRCeXRlKCk7XG4gICAgICAgIHZhciBudW1TaGFwZXMgPSBici5yZWFkSW50MzIoKTtcbiAgICAgICAgdmFyIG51bVZlcnRpY2VzID0gYnIucmVhZEludDMyKCk7XG4gICAgICAgIHZhciBudW1UcmlhbmdsZXMgPSBici5yZWFkSW50MzIoKTtcbiAgICAgICAgdmFyIG51bU1hdHJpY2VzID0gYnIucmVhZEludDMyKCk7O1xuICAgICAgICB2YXIgbnVtUHJvZHVjdHMgPSBici5yZWFkSW50MzIoKTs7XG4gICAgICAgIHZhciBudW1TdHlsZXMgPSBici5yZWFkSW50MzIoKTs7XG4gICAgICAgIHRoaXMubWV0ZXIgPSBici5yZWFkRmxvYXQzMigpOztcbiAgICAgICAgdmFyIG51bVJlZ2lvbnMgPSBici5yZWFkSW50MTYoKTtcblxuXG4gICAgICAgIC8vc2V0IHNpemUgb2YgYXJyYXlzIHRvIGJlIHNxdWFyZSB1c2FibGUgZm9yIHRleHR1cmUgZGF0YVxuICAgICAgICAvL1RPRE86IHJlZmxlY3Qgc3VwcG9ydCBmb3IgZmxvYXRpbmcgcG9pbnQgdGV4dHVyZXNcbiAgICAgICAgdmFyIHNxdWFyZSA9IGZ1bmN0aW9uIChhcml0eSwgY291bnQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGFyaXR5KSA9PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgKGNvdW50KSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93ICdXcm9uZyBhcmd1bWVudHMnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvdW50ID09IDApIHJldHVybiAwO1xuICAgICAgICAgICAgdmFyIGJ5dGVMZW5ndGggPSBjb3VudCAqIGFyaXR5O1xuICAgICAgICAgICAgdmFyIGltZ1NpZGUgPSBNYXRoLmNlaWwoTWF0aC5zcXJ0KGJ5dGVMZW5ndGggLyA0KSk7XG4gICAgICAgICAgICAvL2NsYW1wIHRvIHBhcml0eVxuICAgICAgICAgICAgd2hpbGUgKChpbWdTaWRlICogNCkgJSBhcml0eSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgaW1nU2lkZSsrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gaW1nU2lkZSAqIGltZ1NpZGUgKiA0IC8gYXJpdHk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vY3JlYXRlIHRhcmdldCBidWZmZXJzIG9mIGNvcnJlY3Qgc2l6ZSAoYXZvaWQgcmVhbGxvY2F0aW9uIG9mIG1lbW9yeSlcbiAgICAgICAgdGhpcy52ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoc3F1YXJlKDQsIG51bVZlcnRpY2VzICogMykpO1xuICAgICAgICB0aGlzLm5vcm1hbHMgPSBuZXcgVWludDhBcnJheShudW1UcmlhbmdsZXMgKiA2KTtcbiAgICAgICAgdGhpcy5pbmRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShudW1UcmlhbmdsZXMgKiAzKTtcbiAgICAgICAgdGhpcy5zdHlsZUluZGljZXMgPSBuZXcgVWludDE2QXJyYXkobnVtVHJpYW5nbGVzICogMyk7XG4gICAgICAgIHRoaXMuc3R5bGVzID0gbmV3IFVpbnQ4QXJyYXkoc3F1YXJlKDEsIChudW1TdHlsZXMgKyAxKSAqIDQpKTsgLy8rMSBpcyBmb3IgYSBkZWZhdWx0IHN0eWxlXG4gICAgICAgIHRoaXMucHJvZHVjdHMgPSBuZXcgRmxvYXQzMkFycmF5KG51bVRyaWFuZ2xlcyAqIDMpO1xuICAgICAgICB0aGlzLnN0YXRlcyA9IG5ldyBVaW50OEFycmF5KG51bVRyaWFuZ2xlcyAqIDMgKiAyKTsgLy9wbGFjZSBmb3Igc3RhdGUgYW5kIHJlc3R5bGluZ1xuICAgICAgICB0aGlzLnRyYW5zZm9ybWF0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkobnVtVHJpYW5nbGVzICogMyk7XG4gICAgICAgIHRoaXMubWF0cmljZXMgPSBuZXcgRmxvYXQzMkFycmF5KHNxdWFyZSg0LCBudW1NYXRyaWNlcyAqIDE2KSk7XG4gICAgICAgIHRoaXMucHJvZHVjdE1hcHMgPSB7fTtcbiAgICAgICAgdGhpcy5yZWdpb25zID0gbmV3IEFycmF5PFJlZ2lvbj4obnVtUmVnaW9ucyk7XG5cbiAgICAgICAgdmFyIGlWZXJ0ZXggPSAwO1xuICAgICAgICB2YXIgaUluZGV4Rm9yd2FyZCA9IDA7XG4gICAgICAgIHZhciBpSW5kZXhCYWNrd2FyZCA9IG51bVRyaWFuZ2xlcyAqIDM7XG4gICAgICAgIHZhciBpVHJhbnNmb3JtID0gMDtcbiAgICAgICAgdmFyIGlNYXRyaXggPSAwO1xuXG4gICAgICAgIHZhciBzdGF0ZUVudW0gPSBTdGF0ZTtcbiAgICAgICAgdmFyIHR5cGVFbnVtID0gUHJvZHVjdFR5cGU7XG5cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVJlZ2lvbnM7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlZ2lvbiA9IG5ldyBSZWdpb24oKTtcbiAgICAgICAgICAgIHJlZ2lvbi5wb3B1bGF0aW9uID0gYnIucmVhZEludDMyKCk7XG4gICAgICAgICAgICByZWdpb24uY2VudHJlID0gYnIucmVhZEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgICAgIHJlZ2lvbi5iYm94ID0gYnIucmVhZEZsb2F0MzJBcnJheSg2KTtcbiAgICAgICAgICAgIHRoaXMucmVnaW9uc1tpXSA9IHJlZ2lvbjtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdmFyIHN0eWxlTWFwID0gW107XG4gICAgICAgIHN0eWxlTWFwWydnZXRTdHlsZSddID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uaWQgPT0gaWQpIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBpU3R5bGUgPSAwO1xuICAgICAgICBmb3IgKGlTdHlsZTsgaVN0eWxlIDwgbnVtU3R5bGVzOyBpU3R5bGUrKykge1xuICAgICAgICAgICAgdmFyIHN0eWxlSWQgPSBici5yZWFkSW50MzIoKTtcbiAgICAgICAgICAgIHZhciBSID0gYnIucmVhZEZsb2F0MzIoKSAqIDI1NTtcbiAgICAgICAgICAgIHZhciBHID0gYnIucmVhZEZsb2F0MzIoKSAqIDI1NTtcbiAgICAgICAgICAgIHZhciBCID0gYnIucmVhZEZsb2F0MzIoKSAqIDI1NTtcbiAgICAgICAgICAgIHZhciBBID0gYnIucmVhZEZsb2F0MzIoKSAqIDI1NTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzLnNldChbUiwgRywgQiwgQV0sIGlTdHlsZSAqIDQpO1xuICAgICAgICAgICAgc3R5bGVNYXAucHVzaCh7IGlkOiBzdHlsZUlkLCBpbmRleDogaVN0eWxlLCB0cmFuc3BhcmVudDogQSA8IDI1NCB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0eWxlcy5zZXQoWzI1NSwgMjU1LCAyNTUsIDI1NV0sIGlTdHlsZSAqIDQpO1xuICAgICAgICB2YXIgZGVmYXVsdFN0eWxlID0geyBpZDogLTEsIGluZGV4OiBpU3R5bGUsIHRyYW5zcGFyZW50OiBBIDwgMjU0IH1cbiAgICAgICAgc3R5bGVNYXAucHVzaChkZWZhdWx0U3R5bGUpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtUHJvZHVjdHM7IGkrKykge1xuICAgICAgICAgICAgdmFyIHByb2R1Y3RMYWJlbCA9IGJyLnJlYWRJbnQzMigpO1xuICAgICAgICAgICAgdmFyIHByb2RUeXBlID0gYnIucmVhZEludDE2KCk7XG4gICAgICAgICAgICB2YXIgYkJveCA9IGJyLnJlYWRGbG9hdDMyQXJyYXkoNik7XG5cbiAgICAgICAgICAgIHZhciBtYXAgPSB7XG4gICAgICAgICAgICAgICAgcHJvZHVjdElEOiBwcm9kdWN0TGFiZWwsXG4gICAgICAgICAgICAgICAgdHlwZTogcHJvZFR5cGUsXG4gICAgICAgICAgICAgICAgYkJveDogYkJveCxcbiAgICAgICAgICAgICAgICBzcGFuczogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnByb2R1Y3RNYXBzW3Byb2R1Y3RMYWJlbF0gPSBtYXA7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpU2hhcGUgPSAwOyBpU2hhcGUgPCBudW1TaGFwZXM7IGlTaGFwZSsrKSB7XG5cbiAgICAgICAgICAgIHZhciByZXBldGl0aW9uID0gYnIucmVhZEludDMyKCk7XG4gICAgICAgICAgICB2YXIgc2hhcGVMaXN0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpUHJvZHVjdCA9IDA7IGlQcm9kdWN0IDwgcmVwZXRpdGlvbjsgaVByb2R1Y3QrKykge1xuICAgICAgICAgICAgICAgIHZhciBwcm9kTGFiZWwgPSBici5yZWFkSW50MzIoKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2VUeXBlSWQgPSBici5yZWFkSW50MTYoKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2VMYWJlbCA9IGJyLnJlYWRJbnQzMigpO1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZUlkID0gYnIucmVhZEludDMyKCk7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWF0aW9uID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIC8vIGlmIChyZXBldGl0aW9uID4gMSkge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWF0aW9uID0gdmVyc2lvbiA9PT0gMSA/IGJyLnJlYWRGbG9hdDMyQXJyYXkoMTYpIDogYnIucmVhZEZsb2F0NjRBcnJheSgxNik7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRyaWNlcy5zZXQodHJhbnNmb3JtYXRpb24sIGlNYXRyaXgpO1xuICAgICAgICAgICAgICAgIGlNYXRyaXggKz0gMTY7XG4gICAgICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICAgICAgLy8gcmVhZCBvdXQgdHJhbnNmb3JtYXRpb24gbnVtIHRyYW5nbGVzXG4gICAgICAgICAgICAgICAgYnIucmVhZEludDMyKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgc3R5bGVJdGVtID0gc3R5bGVNYXBbJ2dldFN0eWxlJ10oc3R5bGVJZCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlSXRlbSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVJdGVtID0gZGVmYXVsdFN0eWxlO1xuXG4gICAgICAgICAgICAgICAgc2hhcGVMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBwTGFiZWw6IHByb2RMYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgaUxhYmVsOiBpbnN0YW5jZUxhYmVsLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogc3R5bGVJdGVtLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICB0cmFuc3BhcmVudDogc3R5bGVJdGVtLnRyYW5zcGFyZW50LFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybWF0aW9uICE9IG51bGwgPyBpVHJhbnNmb3JtKysgOiAtMVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3JlYWQgc2hhcGUgZ2VvbWV0cnlcbiAgICAgICAgICAgIHZhciBzaGFwZUdlb20gPSBuZXcgVHJpYW5ndWxhdGVkU2hhcGUoKTtcblxuICAgICAgICAgICAgLy8gcmVhZCBvdXQgZ2VvbWV0cnkgbnVtIHZlcnRpY2VzXG4gICAgICAgICAgICBici5yZWFkSW50MzIoKTtcbiAgICAgICAgICAgIC8vIHJlYWQgb3V0IGxlbmd0aFxuICAgICAgICAgICAgYnIucmVhZEludDMyKCk7XG5cbiAgICAgICAgICAgIHNoYXBlR2VvbS5wYXJzZShicik7XG5cblxuICAgICAgICAgICAgLy9jb3B5IHNoYXBlIGRhdGEgaW50byBpbm5lciBhcnJheSBhbmQgc2V0IHRvIG51bGwgc28gaXQgY2FuIGJlIGdhcmJhZ2UgY29sbGVjdGVkXG4gICAgICAgICAgICBzaGFwZUxpc3QuZm9yRWFjaChzaGFwZSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIGlJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgLy9zZXQgaUluZGV4IGFjY29yZGluZyB0byB0cmFuc3BhcmVuY3kgZWl0aGVyIGZyb20gYmVnaW5uaW5nIG9yIGF0IHRoZSBlbmRcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGUudHJhbnNwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaUluZGV4ID0gaUluZGV4QmFja3dhcmQgLSBzaGFwZUdlb20uaW5kaWNlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaUluZGV4ID0gaUluZGV4Rm9yd2FyZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgYmVnaW4gPSBpSW5kZXg7XG4gICAgICAgICAgICAgICAgdmFyIG1hcCA9IHRoaXMucHJvZHVjdE1hcHNbc2hhcGUucExhYmVsXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChtYXApID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdGhyb3cgXCJQcm9kdWN0IGhhc24ndCBiZWVuIGRlZmluZWQgYmVmb3JlLlwiO1xuICAgICAgICAgICAgICAgICAgICBtYXAgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SUQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlRW51bS5JRkNPUEVOSU5HRUxFTUVOVCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJCb3g6IG5ldyBGbG9hdDMyQXJyYXkoNiksXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuczogW11cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9kdWN0TWFwc1tzaGFwZS5wTGFiZWxdID0gbWFwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMubm9ybWFscy5zZXQoc2hhcGVHZW9tLm5vcm1hbHMsIGlJbmRleCAqIDIpO1xuXG4gICAgICAgICAgICAgICAgLy9zd2l0Y2ggc3BhY2VzIGFuZCBvcGVuaW5ncyBvZmYgYnkgZGVmYXVsdFxuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IG1hcC50eXBlID09IHR5cGVFbnVtLklGQ1NQQUNFIHx8IG1hcC50eXBlID09IHR5cGVFbnVtLklGQ09QRU5JTkdFTEVNRU5UXG4gICAgICAgICAgICAgICAgICAgID8gc3RhdGVFbnVtLkhJRERFTlxuICAgICAgICAgICAgICAgICAgICA6IDB4RkY7IC8vMHhGRiBpcyBmb3IgdGhlIGRlZmF1bHQgc3RhdGVcblxuICAgICAgICAgICAgICAgIC8vZml4IGluZGljZXMgdG8gcmlnaHQgYWJzb2x1dGUgcG9zaXRpb24uIEl0IGlzIHJlbGF0aXZlIHRvIHRoZSBzaGFwZS5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNoYXBlR2VvbS5pbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kaWNlc1tpSW5kZXhdID0gc2hhcGVHZW9tLmluZGljZXNbaV0gKyBpVmVydGV4IC8gMztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9kdWN0c1tpSW5kZXhdID0gc2hhcGUucExhYmVsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0eWxlSW5kaWNlc1tpSW5kZXhdID0gc2hhcGUuc3R5bGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtYXRpb25zW2lJbmRleF0gPSBzaGFwZS50cmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVzWzIgKiBpSW5kZXhdID0gc3RhdGU7IC8vc2V0IHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVzWzIgKiBpSW5kZXggKyAxXSA9IDB4RkY7IC8vZGVmYXVsdCBzdHlsZVxuXG4gICAgICAgICAgICAgICAgICAgIGlJbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBpSW5kZXg7XG4gICAgICAgICAgICAgICAgbWFwLnNwYW5zLnB1c2gobmV3IEludDMyQXJyYXkoW2JlZ2luLCBlbmRdKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2hhcGUudHJhbnNwYXJlbnQpIGlJbmRleEJhY2t3YXJkIC09IHNoYXBlR2VvbS5pbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBlbHNlIGlJbmRleEZvcndhcmQgKz0gc2hhcGVHZW9tLmluZGljZXMubGVuZ3RoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aGlzKTtcblxuICAgICAgICAgICAgLy9jb3B5IGdlb21ldHJ5IGFuZCBrZWVwIHRyYWNrIG9mIGFtb3VudCBzbyB0aGF0IHdlIGNhbiBmaXggaW5kaWNlcyB0byByaWdodCBwb3NpdGlvblxuICAgICAgICAgICAgLy90aGlzIG11c3QgYmUgdGhlIGxhc3Qgc3RlcCB0byBoYXZlIGNvcnJlY3QgaVZlcnRleCBudW1iZXIgYWJvdmVcbiAgICAgICAgICAgIHRoaXMudmVydGljZXMuc2V0KHNoYXBlR2VvbS52ZXJ0aWNlcywgaVZlcnRleCk7XG4gICAgICAgICAgICBpVmVydGV4ICs9IHNoYXBlR2VvbS52ZXJ0aWNlcy5sZW5ndGg7XG4gICAgICAgICAgICBzaGFwZUdlb20gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9iaW5hcnkgcmVhZGVyIHNob3VsZCBiZSBhdCB0aGUgZW5kIGJ5IG5vd1xuICAgICAgICBpZiAoIWJyLmlzRU9GKCkpIHtcbiAgICAgICAgICAgIC8vdGhyb3cgJ0JpbmFyeSByZWFkZXIgaXMgbm90IGF0IHRoZSBlbmQgb2YgdGhlIGZpbGUuJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJhbnNwYXJlbnRJbmRleCA9IGlJbmRleEZvcndhcmQ7XG4gICAgfVxuXG4gICAgLy9Tb3VyY2UgaGFzIHRvIGJlIGVpdGhlciBVUkwgb2Ygd2V4QklNIGZpbGUgb3IgQmxvYiByZXByZXNlbnRpbmcgd2V4QklNIGZpbGVcbiAgICBwdWJsaWMgbG9hZE5ldyhzb3VyY2UpIHtcbiAgICAgICAgLy9iaW5hcnkgcmVhZGluZ1xuICAgICAgICB2YXIgYnIgPSBuZXcgQmluYXJ5UmVhZGVyKCk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgYnIub25sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLnBhcnNlTmV3KGJyKTtcbiAgICAgICAgICAgIGlmIChzZWxmLm9ubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5vbmxvYWRlZCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYnIub25lcnJvciA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLm9uZXJyb3IpIHNlbGYub25lcnJvcihtc2cpO1xuICAgICAgICB9O1xuICAgICAgICBici5sb2FkKHNvdXJjZSk7XG4gICAgfVxuXG5cbiAgICBwdWJsaWMgcGFyc2UoYmluUmVhZGVyOiBCaW5hcnlSZWFkZXIpIHtcbiAgICAgICAgdmFyIGJyID0gYmluUmVhZGVyO1xuICAgICAgICB2YXIgbWFnaWNOdW1iZXIgPSBici5yZWFkSW50MzIoKTtcbiAgICAgICAgaWYgKG1hZ2ljTnVtYmVyICE9IDk0MTMyMTE3KSB0aHJvdyAnTWFnaWMgbnVtYmVyIG1pc21hdGNoLic7XG4gICAgICAgIHZhciB2ZXJzaW9uID0gYnIucmVhZEJ5dGUoKTtcbiAgICAgICAgdmFyIG51bVNoYXBlcyA9IGJyLnJlYWRJbnQzMigpO1xuICAgICAgICB2YXIgbnVtVmVydGljZXMgPSBici5yZWFkSW50MzIoKTtcbiAgICAgICAgdmFyIG51bVRyaWFuZ2xlcyA9IGJyLnJlYWRJbnQzMigpO1xuICAgICAgICB2YXIgbnVtTWF0cmljZXMgPSBici5yZWFkSW50MzIoKTs7XG4gICAgICAgIHZhciBudW1Qcm9kdWN0cyA9IGJyLnJlYWRJbnQzMigpOztcbiAgICAgICAgdmFyIG51bVN0eWxlcyA9IGJyLnJlYWRJbnQzMigpOztcbiAgICAgICAgdGhpcy5tZXRlciA9IGJyLnJlYWRGbG9hdDMyKCk7O1xuICAgICAgICB2YXIgbnVtUmVnaW9ucyA9IGJyLnJlYWRJbnQxNigpO1xuXG5cbiAgICAgICAgLy9zZXQgc2l6ZSBvZiBhcnJheXMgdG8gYmUgc3F1YXJlIHVzYWJsZSBmb3IgdGV4dHVyZSBkYXRhXG4gICAgICAgIC8vVE9ETzogcmVmbGVjdCBzdXBwb3J0IGZvciBmbG9hdGluZyBwb2ludCB0ZXh0dXJlc1xuICAgICAgICB2YXIgc3F1YXJlID0gZnVuY3Rpb24gKGFyaXR5LCBjb3VudCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAoYXJpdHkpID09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiAoY291bnQpID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ1dyb25nIGFyZ3VtZW50cyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY291bnQgPT0gMCkgcmV0dXJuIDA7XG4gICAgICAgICAgICB2YXIgYnl0ZUxlbmd0aCA9IGNvdW50ICogYXJpdHk7XG4gICAgICAgICAgICB2YXIgaW1nU2lkZSA9IE1hdGguY2VpbChNYXRoLnNxcnQoYnl0ZUxlbmd0aCAvIDQpKTtcbiAgICAgICAgICAgIC8vY2xhbXAgdG8gcGFyaXR5XG4gICAgICAgICAgICB3aGlsZSAoKGltZ1NpZGUgKiA0KSAlIGFyaXR5ICE9IDApIHtcbiAgICAgICAgICAgICAgICBpbWdTaWRlKytcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBpbWdTaWRlICogaW1nU2lkZSAqIDQgLyBhcml0eTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy9jcmVhdGUgdGFyZ2V0IGJ1ZmZlcnMgb2YgY29ycmVjdCBzaXplIChhdm9pZCByZWFsbG9jYXRpb24gb2YgbWVtb3J5KVxuICAgICAgICB0aGlzLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShzcXVhcmUoNCwgbnVtVmVydGljZXMgKiAzKSk7XG4gICAgICAgIHRoaXMubm9ybWFscyA9IG5ldyBVaW50OEFycmF5KG51bVRyaWFuZ2xlcyAqIDYpO1xuICAgICAgICB0aGlzLmluZGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KG51bVRyaWFuZ2xlcyAqIDMpO1xuICAgICAgICB0aGlzLnN0eWxlSW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheShudW1UcmlhbmdsZXMgKiAzKTtcbiAgICAgICAgdGhpcy5zdHlsZXMgPSBuZXcgVWludDhBcnJheShzcXVhcmUoMSwgKG51bVN0eWxlcyArIDEpICogNCkpOyAvLysxIGlzIGZvciBhIGRlZmF1bHQgc3R5bGVcbiAgICAgICAgdGhpcy5wcm9kdWN0cyA9IG5ldyBGbG9hdDMyQXJyYXkobnVtVHJpYW5nbGVzICogMyk7XG4gICAgICAgIHRoaXMuc3RhdGVzID0gbmV3IFVpbnQ4QXJyYXkobnVtVHJpYW5nbGVzICogMyAqIDIpOyAvL3BsYWNlIGZvciBzdGF0ZSBhbmQgcmVzdHlsaW5nXG4gICAgICAgIHRoaXMudHJhbnNmb3JtYXRpb25zID0gbmV3IEZsb2F0MzJBcnJheShudW1UcmlhbmdsZXMgKiAzKTtcbiAgICAgICAgdGhpcy5tYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoc3F1YXJlKDQsIG51bU1hdHJpY2VzICogMTYpKTtcbiAgICAgICAgdGhpcy5wcm9kdWN0TWFwcyA9IHt9O1xuICAgICAgICB0aGlzLnJlZ2lvbnMgPSBuZXcgQXJyYXk8UmVnaW9uPihudW1SZWdpb25zKTtcblxuICAgICAgICB2YXIgaVZlcnRleCA9IDA7XG4gICAgICAgIHZhciBpSW5kZXhGb3J3YXJkID0gMDtcbiAgICAgICAgdmFyIGlJbmRleEJhY2t3YXJkID0gbnVtVHJpYW5nbGVzICogMztcbiAgICAgICAgdmFyIGlUcmFuc2Zvcm0gPSAwO1xuICAgICAgICB2YXIgaU1hdHJpeCA9IDA7XG5cbiAgICAgICAgdmFyIHN0YXRlRW51bSA9IFN0YXRlO1xuICAgICAgICB2YXIgdHlwZUVudW0gPSBQcm9kdWN0VHlwZTtcblxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtUmVnaW9uczsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmVnaW9uID0gbmV3IFJlZ2lvbigpO1xuICAgICAgICAgICAgcmVnaW9uLnBvcHVsYXRpb24gPSBici5yZWFkSW50MzIoKTtcbiAgICAgICAgICAgIHJlZ2lvbi5jZW50cmUgPSBici5yZWFkRmxvYXQzMkFycmF5KDMpO1xuICAgICAgICAgICAgcmVnaW9uLmJib3ggPSBici5yZWFkRmxvYXQzMkFycmF5KDYpO1xuICAgICAgICAgICAgdGhpcy5yZWdpb25zW2ldID0gcmVnaW9uO1xuICAgICAgICB9XG5cblxuICAgICAgICB2YXIgc3R5bGVNYXAgPSBbXTtcbiAgICAgICAgc3R5bGVNYXBbJ2dldFN0eWxlJ10gPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gdGhpc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5pZCA9PSBpZCkgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGlTdHlsZSA9IDA7XG4gICAgICAgIGZvciAoaVN0eWxlOyBpU3R5bGUgPCBudW1TdHlsZXM7IGlTdHlsZSsrKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGVJZCA9IGJyLnJlYWRJbnQzMigpO1xuICAgICAgICAgICAgdmFyIFIgPSBici5yZWFkRmxvYXQzMigpICogMjU1O1xuICAgICAgICAgICAgdmFyIEcgPSBici5yZWFkRmxvYXQzMigpICogMjU1O1xuICAgICAgICAgICAgdmFyIEIgPSBici5yZWFkRmxvYXQzMigpICogMjU1O1xuICAgICAgICAgICAgdmFyIEEgPSBici5yZWFkRmxvYXQzMigpICogMjU1O1xuICAgICAgICAgICAgdGhpcy5zdHlsZXMuc2V0KFtSLCBHLCBCLCBBXSwgaVN0eWxlICogNCk7XG4gICAgICAgICAgICBzdHlsZU1hcC5wdXNoKHsgaWQ6IHN0eWxlSWQsIGluZGV4OiBpU3R5bGUsIHRyYW5zcGFyZW50OiBBIDwgMjU0IH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3R5bGVzLnNldChbMjU1LCAyNTUsIDI1NSwgMjU1XSwgaVN0eWxlICogNCk7XG4gICAgICAgIHZhciBkZWZhdWx0U3R5bGUgPSB7IGlkOiAtMSwgaW5kZXg6IGlTdHlsZSwgdHJhbnNwYXJlbnQ6IEEgPCAyNTQgfVxuICAgICAgICBzdHlsZU1hcC5wdXNoKGRlZmF1bHRTdHlsZSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Qcm9kdWN0czsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcHJvZHVjdExhYmVsID0gYnIucmVhZEludDMyKCk7XG4gICAgICAgICAgICB2YXIgcHJvZFR5cGUgPSBici5yZWFkSW50MTYoKTtcbiAgICAgICAgICAgIHZhciBiQm94ID0gYnIucmVhZEZsb2F0MzJBcnJheSg2KTtcblxuICAgICAgICAgICAgdmFyIG1hcCA9IHtcbiAgICAgICAgICAgICAgICBwcm9kdWN0SUQ6IHByb2R1Y3RMYWJlbCxcbiAgICAgICAgICAgICAgICB0eXBlOiBwcm9kVHlwZSxcbiAgICAgICAgICAgICAgICBiQm94OiBiQm94LFxuICAgICAgICAgICAgICAgIHNwYW5zOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucHJvZHVjdE1hcHNbcHJvZHVjdExhYmVsXSA9IG1hcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGlTaGFwZSA9IDA7IGlTaGFwZSA8IG51bVNoYXBlczsgaVNoYXBlKyspIHtcblxuICAgICAgICAgICAgdmFyIHJlcGV0aXRpb24gPSBici5yZWFkSW50MzIoKTtcbiAgICAgICAgICAgIHZhciBzaGFwZUxpc3QgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGlQcm9kdWN0ID0gMDsgaVByb2R1Y3QgPCByZXBldGl0aW9uOyBpUHJvZHVjdCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb2RMYWJlbCA9IGJyLnJlYWRJbnQzMigpO1xuICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZVR5cGVJZCA9IGJyLnJlYWRJbnQxNigpO1xuICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZUxhYmVsID0gYnIucmVhZEludDMyKCk7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlSWQgPSBici5yZWFkSW50MzIoKTtcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtYXRpb24gPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlcGV0aXRpb24gPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWF0aW9uID0gdmVyc2lvbiA9PT0gMSA/IGJyLnJlYWRGbG9hdDMyQXJyYXkoMTYpIDogYnIucmVhZEZsb2F0NjRBcnJheSgxNik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0cmljZXMuc2V0KHRyYW5zZm9ybWF0aW9uLCBpTWF0cml4KTtcbiAgICAgICAgICAgICAgICAgICAgaU1hdHJpeCArPSAxNjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgc3R5bGVJdGVtID0gc3R5bGVNYXBbJ2dldFN0eWxlJ10oc3R5bGVJZCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlSXRlbSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVJdGVtID0gZGVmYXVsdFN0eWxlO1xuXG4gICAgICAgICAgICAgICAgc2hhcGVMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBwTGFiZWw6IHByb2RMYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgaUxhYmVsOiBpbnN0YW5jZUxhYmVsLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogc3R5bGVJdGVtLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICB0cmFuc3BhcmVudDogc3R5bGVJdGVtLnRyYW5zcGFyZW50LFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybWF0aW9uICE9IG51bGwgPyBpVHJhbnNmb3JtKysgOiAtMVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3JlYWQgc2hhcGUgZ2VvbWV0cnlcbiAgICAgICAgICAgIHZhciBzaGFwZUdlb20gPSBuZXcgVHJpYW5ndWxhdGVkU2hhcGUoKTtcbiAgICAgICAgICAgIHNoYXBlR2VvbS5wYXJzZShicik7XG5cblxuICAgICAgICAgICAgLy9jb3B5IHNoYXBlIGRhdGEgaW50byBpbm5lciBhcnJheSBhbmQgc2V0IHRvIG51bGwgc28gaXQgY2FuIGJlIGdhcmJhZ2UgY29sbGVjdGVkXG4gICAgICAgICAgICBzaGFwZUxpc3QuZm9yRWFjaChzaGFwZSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIGlJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgLy9zZXQgaUluZGV4IGFjY29yZGluZyB0byB0cmFuc3BhcmVuY3kgZWl0aGVyIGZyb20gYmVnaW5uaW5nIG9yIGF0IHRoZSBlbmRcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGUudHJhbnNwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaUluZGV4ID0gaUluZGV4QmFja3dhcmQgLSBzaGFwZUdlb20uaW5kaWNlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaUluZGV4ID0gaUluZGV4Rm9yd2FyZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgYmVnaW4gPSBpSW5kZXg7XG4gICAgICAgICAgICAgICAgdmFyIG1hcCA9IHRoaXMucHJvZHVjdE1hcHNbc2hhcGUucExhYmVsXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChtYXApID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdGhyb3cgXCJQcm9kdWN0IGhhc24ndCBiZWVuIGRlZmluZWQgYmVmb3JlLlwiO1xuICAgICAgICAgICAgICAgICAgICBtYXAgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SUQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlRW51bS5JRkNPUEVOSU5HRUxFTUVOVCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJCb3g6IG5ldyBGbG9hdDMyQXJyYXkoNiksXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuczogW11cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9kdWN0TWFwc1tzaGFwZS5wTGFiZWxdID0gbWFwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMubm9ybWFscy5zZXQoc2hhcGVHZW9tLm5vcm1hbHMsIGlJbmRleCAqIDIpO1xuXG4gICAgICAgICAgICAgICAgLy9zd2l0Y2ggc3BhY2VzIGFuZCBvcGVuaW5ncyBvZmYgYnkgZGVmYXVsdFxuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IG1hcC50eXBlID09IHR5cGVFbnVtLklGQ1NQQUNFIHx8IG1hcC50eXBlID09IHR5cGVFbnVtLklGQ09QRU5JTkdFTEVNRU5UXG4gICAgICAgICAgICAgICAgICAgID8gc3RhdGVFbnVtLkhJRERFTlxuICAgICAgICAgICAgICAgICAgICA6IDB4RkY7IC8vMHhGRiBpcyBmb3IgdGhlIGRlZmF1bHQgc3RhdGVcblxuICAgICAgICAgICAgICAgIC8vZml4IGluZGljZXMgdG8gcmlnaHQgYWJzb2x1dGUgcG9zaXRpb24uIEl0IGlzIHJlbGF0aXZlIHRvIHRoZSBzaGFwZS5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNoYXBlR2VvbS5pbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kaWNlc1tpSW5kZXhdID0gc2hhcGVHZW9tLmluZGljZXNbaV0gKyBpVmVydGV4IC8gMztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9kdWN0c1tpSW5kZXhdID0gc2hhcGUucExhYmVsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0eWxlSW5kaWNlc1tpSW5kZXhdID0gc2hhcGUuc3R5bGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtYXRpb25zW2lJbmRleF0gPSBzaGFwZS50cmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVzWzIgKiBpSW5kZXhdID0gc3RhdGU7IC8vc2V0IHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVzWzIgKiBpSW5kZXggKyAxXSA9IDB4RkY7IC8vZGVmYXVsdCBzdHlsZVxuXG4gICAgICAgICAgICAgICAgICAgIGlJbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBpSW5kZXg7XG4gICAgICAgICAgICAgICAgbWFwLnNwYW5zLnB1c2gobmV3IEludDMyQXJyYXkoW2JlZ2luLCBlbmRdKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2hhcGUudHJhbnNwYXJlbnQpIGlJbmRleEJhY2t3YXJkIC09IHNoYXBlR2VvbS5pbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBlbHNlIGlJbmRleEZvcndhcmQgKz0gc2hhcGVHZW9tLmluZGljZXMubGVuZ3RoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aGlzKTtcblxuICAgICAgICAgICAgLy9jb3B5IGdlb21ldHJ5IGFuZCBrZWVwIHRyYWNrIG9mIGFtb3VudCBzbyB0aGF0IHdlIGNhbiBmaXggaW5kaWNlcyB0byByaWdodCBwb3NpdGlvblxuICAgICAgICAgICAgLy90aGlzIG11c3QgYmUgdGhlIGxhc3Qgc3RlcCB0byBoYXZlIGNvcnJlY3QgaVZlcnRleCBudW1iZXIgYWJvdmVcbiAgICAgICAgICAgIHRoaXMudmVydGljZXMuc2V0KHNoYXBlR2VvbS52ZXJ0aWNlcywgaVZlcnRleCk7XG4gICAgICAgICAgICBpVmVydGV4ICs9IHNoYXBlR2VvbS52ZXJ0aWNlcy5sZW5ndGg7XG4gICAgICAgICAgICBzaGFwZUdlb20gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9iaW5hcnkgcmVhZGVyIHNob3VsZCBiZSBhdCB0aGUgZW5kIGJ5IG5vd1xuICAgICAgICBpZiAoIWJyLmlzRU9GKCkpIHtcbiAgICAgICAgICAgIC8vdGhyb3cgJ0JpbmFyeSByZWFkZXIgaXMgbm90IGF0IHRoZSBlbmQgb2YgdGhlIGZpbGUuJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJhbnNwYXJlbnRJbmRleCA9IGlJbmRleEZvcndhcmQ7XG4gICAgfVxuXG4gICAgLy9Tb3VyY2UgaGFzIHRvIGJlIGVpdGhlciBVUkwgb2Ygd2V4QklNIGZpbGUgb3IgQmxvYiByZXByZXNlbnRpbmcgd2V4QklNIGZpbGVcbiAgICBwdWJsaWMgbG9hZChzb3VyY2UpIHtcbiAgICAgICAgLy9iaW5hcnkgcmVhZGluZ1xuICAgICAgICB2YXIgYnIgPSBuZXcgQmluYXJ5UmVhZGVyKCk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgYnIub25sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLnBhcnNlKGJyKTtcbiAgICAgICAgICAgIGlmIChzZWxmLm9ubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5vbmxvYWRlZCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYnIub25lcnJvciA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLm9uZXJyb3IpIHNlbGYub25lcnJvcihtc2cpO1xuICAgICAgICB9O1xuICAgICAgICBici5sb2FkKHNvdXJjZSk7XG4gICAgfVxuXG4gICAgcHVibGljIG9ubG9hZGVkOiAoZ2VvbWV0cnk6IE1vZGVsR2VvbWV0cnkpID0+IHZvaWQ7XG5cbiAgICBwdWJsaWMgb25lcnJvcjogKG1lc3NhZ2U/OiBzdHJpbmcpID0+IHZvaWQ7XG59XG5cblxuZXhwb3J0IGNsYXNzIFByb2R1Y3RNYXAge1xuICAgIHByb2R1Y3RJRDogbnVtYmVyO1xuICAgIHR5cGU6IFByb2R1Y3RUeXBlO1xuICAgIGJCb3g6IEZsb2F0MzJBcnJheTtcbiAgICBzcGFuczogQXJyYXk8SW50MzJBcnJheT47XG59XG5cbmV4cG9ydCBjbGFzcyBSZWdpb24ge1xuICAgIHB1YmxpYyBwb3B1bGF0aW9uOiBudW1iZXIgPSAtMTtcbiAgICBwdWJsaWMgY2VudHJlOiBGbG9hdDMyQXJyYXkgPSBudWxsO1xuICAgIHB1YmxpYyBiYm94OiBGbG9hdDMyQXJyYXkgPSBudWxsO1xuXG4gICAgY29uc3RydWN0b3IocmVnaW9uPzogUmVnaW9uKSB7XG4gICAgICAgIGlmIChyZWdpb24pIHtcbiAgICAgICAgICAgIHRoaXMucG9wdWxhdGlvbiA9IHJlZ2lvbi5wb3B1bGF0aW9uO1xuICAgICAgICAgICAgdGhpcy5jZW50cmUgPSBuZXcgRmxvYXQzMkFycmF5KHJlZ2lvbi5jZW50cmUpO1xuICAgICAgICAgICAgdGhpcy5iYm94ID0gbmV3IEZsb2F0MzJBcnJheShyZWdpb24uYmJveCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNsb25lIG9mIHRoaXMgcmVnaW9uXG4gICAgICovXG4gICAgcHVibGljIGNsb25lKCk6IFJlZ2lvbiB7XG4gICAgICAgIGxldCBjbG9uZSA9IG5ldyBSZWdpb24oKTtcblxuICAgICAgICBjbG9uZS5wb3B1bGF0aW9uID0gdGhpcy5wb3B1bGF0aW9uO1xuICAgICAgICBjbG9uZS5jZW50cmUgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuY2VudHJlKTtcbiAgICAgICAgY2xvbmUuYmJveCA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5iYm94KTtcblxuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBuZXcgcmVnaW9uIHdoaWNoIGlzIGEgbWVyZ2Ugb2YgdGhpcyByZWdpb24gYW5kIHRoZSBhcmd1bWVudFxuICAgICAqIEBwYXJhbSByZWdpb24gcmVnaW9uIHRvIGJlIG1lcmdlZFxuICAgICAqL1xuICAgIHB1YmxpYyBtZXJnZShyZWdpb246IFJlZ2lvbik6IFJlZ2lvbiB7XG4gICAgICAgIC8vaWYgdGhpcyBpcyBhIG5ldyBlbXB0eSByZWdpb24sIHJldHVybiBjbG9uZSBvZiB0aGUgYXJndW1lbnRcbiAgICAgICAgaWYgKHRoaXMucG9wdWxhdGlvbiA9PT0gLTEgJiYgdGhpcy5jZW50cmUgPT09IG51bGwgJiYgdGhpcy5iYm94ID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdpb24ocmVnaW9uKTtcblxuICAgICAgICBsZXQgb3V0ID0gbmV3IFJlZ2lvbigpO1xuICAgICAgICBvdXQucG9wdWxhdGlvbiA9IHRoaXMucG9wdWxhdGlvbiArIHJlZ2lvbi5wb3B1bGF0aW9uO1xuXG4gICAgICAgIGxldCB4ID0gTWF0aC5taW4odGhpcy5iYm94WzBdLCByZWdpb24uYmJveFswXSk7XG4gICAgICAgIGxldCB5ID0gTWF0aC5taW4odGhpcy5iYm94WzFdLCByZWdpb24uYmJveFsxXSk7XG4gICAgICAgIGxldCB6ID0gTWF0aC5taW4odGhpcy5iYm94WzJdLCByZWdpb24uYmJveFsyXSk7XG5cbiAgICAgICAgbGV0IHgyID0gTWF0aC5taW4odGhpcy5iYm94WzBdICsgdGhpcy5iYm94WzNdLCByZWdpb24uYmJveFswXSArIHJlZ2lvbi5iYm94WzNdKTtcbiAgICAgICAgbGV0IHkyID0gTWF0aC5taW4odGhpcy5iYm94WzFdICsgdGhpcy5iYm94WzRdLCByZWdpb24uYmJveFsxXSArIHJlZ2lvbi5iYm94WzRdKTtcbiAgICAgICAgbGV0IHoyID0gTWF0aC5taW4odGhpcy5iYm94WzJdICsgdGhpcy5iYm94WzVdLCByZWdpb24uYmJveFsyXSArIHJlZ2lvbi5iYm94WzVdKTtcblxuICAgICAgICBsZXQgc3ggPSB4MiAtIHg7XG4gICAgICAgIGxldCBzeSA9IHkyIC0geTtcbiAgICAgICAgbGV0IHN6ID0gejIgLSB6O1xuXG4gICAgICAgIGxldCBjeCA9ICh4ICsgeDIpIC8gMi4wO1xuICAgICAgICBsZXQgY3kgPSAoeSArIHkyKSAvIDIuMDtcbiAgICAgICAgbGV0IGN6ID0gKHogKyB6MikgLyAyLjA7XG5cbiAgICAgICAgb3V0LmJib3ggPSBuZXcgRmxvYXQzMkFycmF5KFt4LCB5LCB6LCBzeCwgc3ksIHN6XSk7XG4gICAgICAgIG91dC5jZW50cmUgPSBuZXcgRmxvYXQzMkFycmF5KFtjeCwgY3ksIGN6XSk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vVmlld2VyL21vZGVsLWdlb21ldHJ5LnRzIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQWVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBbWNBO0FBL2JBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFBQTtBQTdkQTtBQWdlQTtBQUFBO0FBS0E7QUFBQTtBQUFBO0FBTEE7QUFPQTtBQUtBO0FBSkE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQTFEQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3\n");

/***/ }),

/***/ 4:
/* no static exports found */
/* all exports used */
/*!*********************************!*\
  !*** ./Viewer/binary-reader.ts ***!
  \*********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Convenient class for binary reading. Arrays are read as new views on slices of the original data buffer,\n * individual values are read using little endian data view.\n */\nvar BinaryReader = (function () {\n    function BinaryReader() {\n        this._buffer = null;\n        this._view = null;\n        this._position = 0;\n    }\n    Object.defineProperty(BinaryReader.prototype, \"Position\", {\n        /**\n         * Current position\n         */\n        get: function () {\n            return this._position;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Pass url string, blob, file of byte array to this function to initialize the reader. Only array buffer takes imidiate effect.\n     * Othe sources are loaded asynchronously and you need to use 'onloaded' delegate to use the reader only after it is initialized woth the data.\n     * @param source URL string of the file or BLOB or File or ArrayBuffer object\n     */\n    BinaryReader.prototype.load = function (source) {\n        this._position = 0;\n        var self = this;\n        if (typeof (source) == 'undefined' || source == null)\n            throw 'Source must be defined';\n        if (typeof (source) == 'string') {\n            var xhr;\n            xhr = new XMLHttpRequest();\n            xhr.open(\"GET\", source, true);\n            xhr.onreadystatechange = function () {\n                if (xhr.readyState == 4 && xhr.status == 200) {\n                    var fReader = new FileReader();\n                    fReader.onloadend = function () {\n                        if (fReader.result) {\n                            //set data buffer for next processing\n                            self._buffer = fReader.result;\n                            self._view = new DataView(self._buffer);\n                            //do predefined processing of the data\n                            if (self.onloaded) {\n                                self.onloaded(self);\n                            }\n                        }\n                    };\n                    fReader.readAsArrayBuffer(xhr.response);\n                }\n                //throw exception as a warning\n                if (xhr.readyState == 4 && xhr.status != 200) {\n                    var msg = 'Failed to fetch binary data from server. Server code: ' +\n                        xhr.status +\n                        '. This might be due to CORS policy of your browser if you run this as a local file.';\n                    if (self.onerror)\n                        self.onerror(msg);\n                    throw msg;\n                }\n            };\n            xhr.responseType = 'blob';\n            xhr.send();\n        }\n        else if (source instanceof Blob || source instanceof File) {\n            var fReader = new FileReader();\n            fReader.onloadend = function () {\n                if (fReader.result) {\n                    //set data buffer for next processing\n                    self._buffer = fReader.result;\n                    self._view = new DataView(self._buffer);\n                    //do predefined processing of the data\n                    if (self.onloaded) {\n                        self.onloaded(self);\n                    }\n                }\n            };\n            fReader.readAsArrayBuffer(source);\n        }\n        else if (source instanceof ArrayBuffer) {\n            this._buffer = source;\n            this._view = new DataView(self._buffer);\n            if (self.onloaded) {\n                self.onloaded(self);\n            }\n        }\n    };\n    BinaryReader.prototype.seek = function (position) {\n        if (position < 0 || position > this._buffer.byteLength)\n            throw \"Position out of range.\";\n        this._position = position;\n    };\n    BinaryReader.prototype.isEOF = function () {\n        if (this._position == null)\n            throw \"Position is not defined\";\n        return this._position == this._buffer.byteLength;\n    };\n    BinaryReader.prototype.readArray = function (unitSize, count, ctor) {\n        if (count == null)\n            count = 1;\n        var length = unitSize * count;\n        var offset = this._position;\n        this._position += length;\n        var result;\n        return count === 1\n            ? new ctor(this._buffer.slice(offset, offset + length))[0]\n            : new ctor(this._buffer.slice(offset, offset + length));\n    };\n    BinaryReader.prototype.move = function (size) {\n        var offset = this._position;\n        this._position += size;\n        return offset;\n    };\n    BinaryReader.prototype.readByte = function () {\n        return this.readUint8();\n    };\n    BinaryReader.prototype.readByteArray = function (count) {\n        return this.readUint8Array(count);\n    };\n    BinaryReader.prototype.readUint8 = function () {\n        var offset = this.move(1);\n        return this._view.getUint8(offset);\n    };\n    BinaryReader.prototype.readUint8Array = function (count) {\n        return this.readArray(1, count, Uint8Array);\n    };\n    BinaryReader.prototype.readInt16 = function () {\n        var offset = this.move(2);\n        return this._view.getInt16(offset, true);\n    };\n    BinaryReader.prototype.readInt16Array = function (count) {\n        return this.readArray(2, count, Int16Array);\n    };\n    BinaryReader.prototype.readUInt16 = function () {\n        var offset = this.move(2);\n        return this._view.getUint16(offset, true);\n    };\n    BinaryReader.prototype.readUint16Array = function (count) {\n        return this.readArray(2, count, Uint16Array);\n    };\n    BinaryReader.prototype.readInt32 = function () {\n        var offset = this.move(4);\n        return this._view.getInt32(offset, true);\n    };\n    BinaryReader.prototype.readInt32Array = function (count) {\n        return this.readArray(4, count, Int32Array);\n    };\n    BinaryReader.prototype.readUint32 = function () {\n        var offset = this.move(4);\n        return this._view.getUint32(offset, true);\n    };\n    BinaryReader.prototype.readUint32Array = function (count) {\n        return this.readArray(4, count, Uint32Array);\n    };\n    BinaryReader.prototype.readFloat32 = function () {\n        var offset = this.move(4);\n        return this._view.getFloat32(offset, true);\n    };\n    BinaryReader.prototype.readFloat32Array = function (count) {\n        return this.readArray(4, count, Float32Array);\n    };\n    BinaryReader.prototype.readFloat64 = function () {\n        var offset = this.move(8);\n        return this._view.getFloat64(offset, true);\n    };\n    BinaryReader.prototype.readFloat64Array = function (count) {\n        return this.readArray(8, count, Float64Array);\n    };\n    //functions for a higher objects like points, colours and matrices\n    BinaryReader.prototype.readChar = function (count) {\n        if (count == null)\n            count = 1;\n        var bytes = this.readByteArray(count);\n        var result = new Array(count);\n        for (var i in bytes) {\n            result[i] = String.fromCharCode(bytes[i]);\n        }\n        return count === 1 ? result[0] : result;\n    };\n    BinaryReader.prototype.readPoint = function (count) {\n        if (count == null)\n            count = 1;\n        var coords = this.readFloat32Array(count * 3);\n        var result = new Array(count);\n        for (var i = 0; i < count; i++) {\n            var offset = i * 3 * 4;\n            //only create new view on the buffer so that no new memory is allocated\n            var point = new Float32Array(coords.buffer, offset, 3);\n            result[i] = point;\n        }\n        return count === 1 ? result[0] : result;\n    };\n    BinaryReader.prototype.readRgba = function (count) {\n        if (count == null)\n            count = 1;\n        var values = this.readByteArray(count * 4);\n        var result = new Array(count);\n        for (var i = 0; i < count; i++) {\n            var offset = i * 4;\n            var colour = new Uint8Array(values.buffer, offset, 4);\n            result[i] = colour;\n        }\n        return count === 1 ? result[0] : result;\n    };\n    BinaryReader.prototype.readPackedNormal = function (count) {\n        if (count == null)\n            count = 1;\n        var values = this.readUint8Array(count * 2);\n        var result = new Array(count);\n        for (var i = 0; i < count; i++) {\n            var uv = new Uint8Array(values.buffer, i * 2, 2);\n            result[i] = uv;\n        }\n        return count === 1 ? result[0] : result;\n    };\n    BinaryReader.prototype.readMatrix4x4 = function (count) {\n        if (count == null)\n            count = 1;\n        var values = this.readFloat32Array(count * 16);\n        var result = new Array(count);\n        for (var i = 0; i < count; i++) {\n            var offset = i * 16 * 4;\n            var matrix = new Float32Array(values.buffer, offset, 16);\n            result[i] = matrix;\n        }\n        return count === 1 ? result[0] : result;\n    };\n    BinaryReader.prototype.readMatrix4x4_64 = function (count) {\n        if (count == null)\n            count = 1;\n        var values = this.readFloat64Array(count * 16);\n        var result = new Array(count);\n        for (var i = 0; i < count; i++) {\n            var offset = i * 16 * 8;\n            var matrix = new Float64Array(values.buffer, offset, 16);\n            result[i] = matrix;\n        }\n        return count === 1 ? result[0] : result;\n    };\n    /**\n     * Reads slice of data from the underlying array buffer\n     * @param length Length of requested data. Start is at current position\n     */\n    BinaryReader.prototype.readData = function (length) {\n        var offset = this.move(length);\n        return this._buffer.slice(offset, offset + length);\n    };\n    return BinaryReader;\n}());\nexports.BinaryReader = BinaryReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL1ZpZXdlci9iaW5hcnktcmVhZGVyLnRzPzcwMDAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb252ZW5pZW50IGNsYXNzIGZvciBiaW5hcnkgcmVhZGluZy4gQXJyYXlzIGFyZSByZWFkIGFzIG5ldyB2aWV3cyBvbiBzbGljZXMgb2YgdGhlIG9yaWdpbmFsIGRhdGEgYnVmZmVyLFxuICogaW5kaXZpZHVhbCB2YWx1ZXMgYXJlIHJlYWQgdXNpbmcgbGl0dGxlIGVuZGlhbiBkYXRhIHZpZXcuIFxuICovXG5leHBvcnQgY2xhc3MgQmluYXJ5UmVhZGVyIHtcbiAgICBwcml2YXRlIF9idWZmZXI6IEFycmF5QnVmZmVyID0gbnVsbDtcbiAgICBwcml2YXRlIF92aWV3OiBEYXRhVmlldyA9IG51bGw7XG4gICAgcHJpdmF0ZSBfcG9zaXRpb246IG51bWJlciA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBjYWxsYmFjayB3aGljaCB3aWxsIGJlIGNhbGxlZCBhZnRlciBhc3luY2hyb25vdXMgbG9hZGluZyBvZiBkYXRhIGlzIGZpbmlzaGVkXG4gICAgICovXG4gICAgcHVibGljIG9ubG9hZGVkOiAocmVhZGVyOiBCaW5hcnlSZWFkZXIpID0+IHZvaWQ7XG5cbiAgICBwdWJsaWMgb25lcnJvcjogKG1lc3NhZ2U/OiBzdHJpbmcpID0+IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHBvc2l0aW9uXG4gICAgICovXG4gICAgcHVibGljIGdldCBQb3NpdGlvbigpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9zaXRpb247XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBQYXNzIHVybCBzdHJpbmcsIGJsb2IsIGZpbGUgb2YgYnl0ZSBhcnJheSB0byB0aGlzIGZ1bmN0aW9uIHRvIGluaXRpYWxpemUgdGhlIHJlYWRlci4gT25seSBhcnJheSBidWZmZXIgdGFrZXMgaW1pZGlhdGUgZWZmZWN0LlxuICAgICAqIE90aGUgc291cmNlcyBhcmUgbG9hZGVkIGFzeW5jaHJvbm91c2x5IGFuZCB5b3UgbmVlZCB0byB1c2UgJ29ubG9hZGVkJyBkZWxlZ2F0ZSB0byB1c2UgdGhlIHJlYWRlciBvbmx5IGFmdGVyIGl0IGlzIGluaXRpYWxpemVkIHdvdGggdGhlIGRhdGEuXG4gICAgICogQHBhcmFtIHNvdXJjZSBVUkwgc3RyaW5nIG9mIHRoZSBmaWxlIG9yIEJMT0Igb3IgRmlsZSBvciBBcnJheUJ1ZmZlciBvYmplY3RcbiAgICAgKi9cbiAgICBwdWJsaWMgbG9hZChzb3VyY2U6IHN0cmluZyB8IEJsb2IgfCBGaWxlIHwgQXJyYXlCdWZmZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fcG9zaXRpb24gPSAwO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHR5cGVvZiAoc291cmNlKSA9PSAndW5kZWZpbmVkJyB8fCBzb3VyY2UgPT0gbnVsbCkgdGhyb3cgJ1NvdXJjZSBtdXN0IGJlIGRlZmluZWQnO1xuICAgICAgICBpZiAodHlwZW9mIChzb3VyY2UpID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgeGhyO1xuICAgICAgICAgICAgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICB4aHIub3BlbihcIkdFVFwiLCBzb3VyY2UsIHRydWUpO1xuICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT0gNCAmJiB4aHIuc3RhdHVzID09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZlJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGZSZWFkZXIub25sb2FkZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZSZWFkZXIucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9zZXQgZGF0YSBidWZmZXIgZm9yIG5leHQgcHJvY2Vzc2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2J1ZmZlciA9IGZSZWFkZXIucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3ZpZXcgPSBuZXcgRGF0YVZpZXcoc2VsZi5fYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2RvIHByZWRlZmluZWQgcHJvY2Vzc2luZyBvZiB0aGUgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLm9ubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYub25sb2FkZWQoc2VsZik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBmUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKHhoci5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vdGhyb3cgZXhjZXB0aW9uIGFzIGEgd2FybmluZ1xuICAgICAgICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PSA0ICYmIHhoci5zdGF0dXMgIT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSAnRmFpbGVkIHRvIGZldGNoIGJpbmFyeSBkYXRhIGZyb20gc2VydmVyLiBTZXJ2ZXIgY29kZTogJyArXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcuIFRoaXMgbWlnaHQgYmUgZHVlIHRvIENPUlMgcG9saWN5IG9mIHlvdXIgYnJvd3NlciBpZiB5b3UgcnVuIHRoaXMgYXMgYSBsb2NhbCBmaWxlLic7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLm9uZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm9uZXJyb3IobXNnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbXNnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InO1xuICAgICAgICAgICAgeGhyLnNlbmQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBCbG9iIHx8IHNvdXJjZSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgICAgIHZhciBmUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgIGZSZWFkZXIub25sb2FkZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChmUmVhZGVyLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAvL3NldCBkYXRhIGJ1ZmZlciBmb3IgbmV4dCBwcm9jZXNzaW5nXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2J1ZmZlciA9IGZSZWFkZXIucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl92aWV3ID0gbmV3IERhdGFWaWV3KHNlbGYuX2J1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgIC8vZG8gcHJlZGVmaW5lZCBwcm9jZXNzaW5nIG9mIHRoZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLm9ubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm9ubG9hZGVkKHNlbGYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoc291cmNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyID0gc291cmNlO1xuICAgICAgICAgICAgdGhpcy5fdmlldyA9IG5ldyBEYXRhVmlldyhzZWxmLl9idWZmZXIpO1xuICAgICAgICAgICAgaWYgKHNlbGYub25sb2FkZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm9ubG9hZGVkKHNlbGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIHNlZWsocG9zaXRpb246IG51bWJlcik6IHZvaWQge1xuICAgICAgICBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID4gdGhpcy5fYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBcIlBvc2l0aW9uIG91dCBvZiByYW5nZS5cIlxuXG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gcG9zaXRpb247XG4gICAgfVxuXG4gICAgcHVibGljIGlzRU9GKCk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAodGhpcy5fcG9zaXRpb24gPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IFwiUG9zaXRpb24gaXMgbm90IGRlZmluZWRcIjtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uID09IHRoaXMuX2J1ZmZlci5ieXRlTGVuZ3RoO1xuICAgIH1cblxuICAgIHByaXZhdGUgcmVhZEFycmF5PFQ+KHVuaXRTaXplOiBudW1iZXIsIGNvdW50OiBudW1iZXIsIGN0b3I6IG5ldyAoZGF0YTogQXJyYXlCdWZmZXIpID0+IFQpOiBUIHtcbiAgICAgICAgaWYgKGNvdW50ID09IG51bGwpXG4gICAgICAgICAgICBjb3VudCA9IDE7XG4gICAgICAgIHZhciBsZW5ndGggPSB1bml0U2l6ZSAqIGNvdW50O1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fcG9zaXRpb247XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uICs9IGxlbmd0aDtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICByZXR1cm4gY291bnQgPT09IDFcbiAgICAgICAgICAgID8gbmV3IGN0b3IodGhpcy5fYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKSlbMF1cbiAgICAgICAgICAgIDogbmV3IGN0b3IodGhpcy5fYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBtb3ZlKHNpemU6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5fcG9zaXRpb24gKz0gc2l6ZTtcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVhZEJ5dGUoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZFVpbnQ4KCk7XG4gICAgfVxuXG4gICAgcHVibGljIHJlYWRCeXRlQXJyYXkoY291bnQ6IG51bWJlcik6IFVpbnQ4QXJyYXkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkVWludDhBcnJheShjb3VudCk7XG4gICAgfVxuXG4gICAgcHVibGljIHJlYWRVaW50OCgpOiBudW1iZXIge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5tb3ZlKDEpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlldy5nZXRVaW50OChvZmZzZXQpO1xuICAgIH1cblxuICAgIHB1YmxpYyByZWFkVWludDhBcnJheShjb3VudDogbnVtYmVyKTogVWludDhBcnJheSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRBcnJheSgxLCBjb3VudCwgVWludDhBcnJheSk7XG4gICAgfVxuXG4gICAgcHVibGljIHJlYWRJbnQxNigpOiBudW1iZXIge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5tb3ZlKDIpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlldy5nZXRJbnQxNihvZmZzZXQsIHRydWUpO1xuICAgIH1cblxuICAgIHB1YmxpYyByZWFkSW50MTZBcnJheShjb3VudDogbnVtYmVyKTogSW50MTZBcnJheSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRBcnJheSgyLCBjb3VudCwgSW50MTZBcnJheSk7XG4gICAgfVxuXG4gICAgcHVibGljIHJlYWRVSW50MTYoKTogbnVtYmVyIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMubW92ZSgyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXcuZ2V0VWludDE2KG9mZnNldCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcHVibGljIHJlYWRVaW50MTZBcnJheShjb3VudDogbnVtYmVyKTogVWludDE2QXJyYXkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkQXJyYXkoMiwgY291bnQsIFVpbnQxNkFycmF5KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVhZEludDMyKCk6IG51bWJlciB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLm1vdmUoNCk7XG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3LmdldEludDMyKG9mZnNldCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcHVibGljIHJlYWRJbnQzMkFycmF5KGNvdW50OiBudW1iZXIpOiBJbnQzMkFycmF5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZEFycmF5KDQsIGNvdW50LCBJbnQzMkFycmF5KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVhZFVpbnQzMigpOiBudW1iZXIge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5tb3ZlKDQpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlldy5nZXRVaW50MzIob2Zmc2V0LCB0cnVlKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVhZFVpbnQzMkFycmF5KGNvdW50OiBudW1iZXIpOiBVaW50MzJBcnJheSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRBcnJheSg0LCBjb3VudCwgVWludDMyQXJyYXkpO1xuICAgIH1cblxuICAgIHB1YmxpYyByZWFkRmxvYXQzMigpOiBudW1iZXIge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5tb3ZlKDQpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlldy5nZXRGbG9hdDMyKG9mZnNldCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcHVibGljIHJlYWRGbG9hdDMyQXJyYXkoY291bnQ6IG51bWJlcik6IEZsb2F0MzJBcnJheSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRBcnJheSg0LCBjb3VudCwgRmxvYXQzMkFycmF5KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVhZEZsb2F0NjQoKTogbnVtYmVyIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMubW92ZSg4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXcuZ2V0RmxvYXQ2NChvZmZzZXQsIHRydWUpO1xuICAgIH1cblxuICAgIHB1YmxpYyByZWFkRmxvYXQ2NEFycmF5KGNvdW50OiBudW1iZXIpOiBGbG9hdDY0QXJyYXkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkQXJyYXkoOCwgY291bnQsIEZsb2F0NjRBcnJheSk7XG4gICAgfVxuXG4gICAgLy9mdW5jdGlvbnMgZm9yIGEgaGlnaGVyIG9iamVjdHMgbGlrZSBwb2ludHMsIGNvbG91cnMgYW5kIG1hdHJpY2VzXG4gICAgcHVibGljIHJlYWRDaGFyKGNvdW50PzogbnVtYmVyKSB7XG4gICAgICAgIGlmIChjb3VudCA9PSBudWxsKVxuICAgICAgICAgICAgY291bnQgPSAxO1xuICAgICAgICB2YXIgYnl0ZXMgPSB0aGlzLnJlYWRCeXRlQXJyYXkoY291bnQpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBieXRlcykge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50ID09PSAxID8gcmVzdWx0WzBdIDogcmVzdWx0O1xuICAgIH1cblxuICAgIHB1YmxpYyByZWFkUG9pbnQoY291bnQ/OiBudW1iZXIpIHtcbiAgICAgICAgaWYgKGNvdW50ID09IG51bGwpXG4gICAgICAgICAgICBjb3VudCA9IDE7XG4gICAgICAgIHZhciBjb29yZHMgPSB0aGlzLnJlYWRGbG9hdDMyQXJyYXkoY291bnQgKiAzKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGkgKiAzICogNDtcbiAgICAgICAgICAgIC8vb25seSBjcmVhdGUgbmV3IHZpZXcgb24gdGhlIGJ1ZmZlciBzbyB0aGF0IG5vIG5ldyBtZW1vcnkgaXMgYWxsb2NhdGVkXG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBuZXcgRmxvYXQzMkFycmF5KGNvb3Jkcy5idWZmZXIsIG9mZnNldCwgMyk7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSBwb2ludDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnQgPT09IDEgPyByZXN1bHRbMF0gOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcHVibGljIHJlYWRSZ2JhKGNvdW50PzogbnVtYmVyKSB7XG4gICAgICAgIGlmIChjb3VudCA9PSBudWxsKVxuICAgICAgICAgICAgY291bnQgPSAxO1xuICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy5yZWFkQnl0ZUFycmF5KGNvdW50ICogNCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpICogNDtcbiAgICAgICAgICAgIHZhciBjb2xvdXIgPSBuZXcgVWludDhBcnJheSh2YWx1ZXMuYnVmZmVyLCBvZmZzZXQsIDQpO1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gY29sb3VyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3VudCA9PT0gMSA/IHJlc3VsdFswXSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVhZFBhY2tlZE5vcm1hbChjb3VudD86IG51bWJlcikge1xuICAgICAgICBpZiAoY291bnQgPT0gbnVsbClcbiAgICAgICAgICAgIGNvdW50ID0gMTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMucmVhZFVpbnQ4QXJyYXkoY291bnQgKiAyKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIHV2ID0gbmV3IFVpbnQ4QXJyYXkodmFsdWVzLmJ1ZmZlciwgaSAqIDIsIDIpO1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gdXY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50ID09PSAxID8gcmVzdWx0WzBdIDogcmVzdWx0O1xuICAgIH1cblxuICAgIHB1YmxpYyByZWFkTWF0cml4NHg0KGNvdW50PzogbnVtYmVyKSB7XG4gICAgICAgIGlmIChjb3VudCA9PSBudWxsKVxuICAgICAgICAgICAgY291bnQgPSAxO1xuICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy5yZWFkRmxvYXQzMkFycmF5KGNvdW50ICogMTYpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaSAqIDE2ICogNDtcbiAgICAgICAgICAgIHZhciBtYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KHZhbHVlcy5idWZmZXIsIG9mZnNldCwgMTYpO1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gbWF0cml4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3VudCA9PT0gMSA/IHJlc3VsdFswXSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVhZE1hdHJpeDR4NF82NChjb3VudD86IG51bWJlcikge1xuICAgICAgICBpZiAoY291bnQgPT0gbnVsbClcbiAgICAgICAgICAgIGNvdW50ID0gMTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMucmVhZEZsb2F0NjRBcnJheShjb3VudCAqIDE2KTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGkgKiAxNiAqIDg7XG4gICAgICAgICAgICB2YXIgbWF0cml4ID0gbmV3IEZsb2F0NjRBcnJheSh2YWx1ZXMuYnVmZmVyLCBvZmZzZXQsIDE2KTtcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IG1hdHJpeDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnQgPT09IDEgPyByZXN1bHRbMF0gOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVhZHMgc2xpY2Ugb2YgZGF0YSBmcm9tIHRoZSB1bmRlcmx5aW5nIGFycmF5IGJ1ZmZlclxuICAgICAqIEBwYXJhbSBsZW5ndGggTGVuZ3RoIG9mIHJlcXVlc3RlZCBkYXRhLiBTdGFydCBpcyBhdCBjdXJyZW50IHBvc2l0aW9uXG4gICAgICovXG4gICAgcHVibGljIHJlYWREYXRhKGxlbmd0aDogbnVtYmVyKTogQXJyYXlCdWZmZXIge1xuICAgICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5tb3ZlKGxlbmd0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL1ZpZXdlci9iaW5hcnktcmVhZGVyLnRzIl0sIm1hcHBpbmdzIjoiOztBQUFBOzs7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUE4UUE7QUFsUUE7QUFIQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFHQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBalJBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4\n");

/***/ }),

/***/ 8:
/* no static exports found */
/* all exports used */
/*!**************************************!*\
  !*** ./Viewer/triangulated-shape.ts ***!
  \**************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar binary_reader_1 = __webpack_require__(/*! ./binary-reader */ 4);\nvar TriangulatedShape = (function () {\n    function TriangulatedShape() {\n        //This would load only shape data from binary file\n        this.load = function (source) {\n            //binary reading\n            var br = new binary_reader_1.BinaryReader();\n            var self = this;\n            br.onloaded = function () {\n                self.parse(br);\n                if (self.onloaded) {\n                    self.onloaded(this);\n                }\n            };\n            br.load(source);\n        };\n    }\n    //this will get xBinaryReader on the current position and will parse it's content to fill itself with vertices, normals and vertex indices\n    TriangulatedShape.prototype.parse = function (binReader) {\n        var self = this;\n        var version = binReader.readByte();\n        var numVertices = binReader.readInt32();\n        var numOfTriangles = binReader.readInt32();\n        self.vertices = binReader.readFloat32Array(numVertices * 3);\n        //allocate memory of defined size (to avoid reallocation of memory)\n        self.indices = new Uint32Array(numOfTriangles * 3);\n        self.normals = new Uint8Array(numOfTriangles * 6);\n        //indices for incremental adding of indices and normals\n        var iIndex = 0;\n        var readIndex;\n        if (numVertices <= 0xFF) {\n            readIndex = function (count) { return binReader.readByteArray(count); };\n        }\n        else if (numVertices <= 0xFFFF) {\n            readIndex = function (count) { return binReader.readUint16Array(count); };\n        }\n        else {\n            readIndex = function (count) { return binReader.readInt32Array(count); };\n        }\n        var numFaces = binReader.readInt32();\n        if (numVertices === 0 || numOfTriangles === 0)\n            return;\n        for (var i = 0; i < numFaces; i++) {\n            var numTrianglesInFace = binReader.readInt32();\n            if (numTrianglesInFace == 0)\n                continue;\n            var isPlanar = numTrianglesInFace > 0;\n            numTrianglesInFace = Math.abs(numTrianglesInFace);\n            if (isPlanar) {\n                var normal = binReader.readByteArray(2);\n                //read and set all indices\n                var planarIndices = readIndex(3 * numTrianglesInFace);\n                self.indices.set(planarIndices, iIndex);\n                for (var j = 0; j < numTrianglesInFace * 3; j++) {\n                    //add three identical normals because this is planar but needs to be expanded for WebGL\n                    self.normals[iIndex * 2] = normal[0];\n                    self.normals[iIndex * 2 + 1] = normal[1];\n                    iIndex++;\n                }\n            }\n            else {\n                for (var j = 0; j < numTrianglesInFace; j++) {\n                    self.indices[iIndex] = readIndex(); //a\n                    self.normals.set(binReader.readByteArray(2), iIndex * 2);\n                    iIndex++;\n                    self.indices[iIndex] = readIndex(); //b\n                    self.normals.set(binReader.readByteArray(2), iIndex * 2);\n                    iIndex++;\n                    self.indices[iIndex] = readIndex(); //c\n                    self.normals.set(binReader.readByteArray(2), iIndex * 2);\n                    iIndex++;\n                }\n            }\n        }\n    };\n    return TriangulatedShape;\n}());\nexports.TriangulatedShape = TriangulatedShape;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL1ZpZXdlci90cmlhbmd1bGF0ZWQtc2hhcGUudHM/MDVhYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCaW5hcnlSZWFkZXIgfSBmcm9tIFwiLi9iaW5hcnktcmVhZGVyXCI7XG5cbmV4cG9ydCBjbGFzcyBUcmlhbmd1bGF0ZWRTaGFwZSB7XG5cbiAgICAvL3RoaXMgd2lsbCBnZXQgeEJpbmFyeVJlYWRlciBvbiB0aGUgY3VycmVudCBwb3NpdGlvbiBhbmQgd2lsbCBwYXJzZSBpdCdzIGNvbnRlbnQgdG8gZmlsbCBpdHNlbGYgd2l0aCB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdmVydGV4IGluZGljZXNcbiAgICBwdWJsaWMgcGFyc2UoYmluUmVhZGVyOiBCaW5hcnlSZWFkZXIpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgdmVyc2lvbiA9IGJpblJlYWRlci5yZWFkQnl0ZSgpO1xuICAgICAgICB2YXIgbnVtVmVydGljZXMgPSBiaW5SZWFkZXIucmVhZEludDMyKCk7XG4gICAgICAgIHZhciBudW1PZlRyaWFuZ2xlcyA9IGJpblJlYWRlci5yZWFkSW50MzIoKTtcbiAgICAgICAgc2VsZi52ZXJ0aWNlcyA9IGJpblJlYWRlci5yZWFkRmxvYXQzMkFycmF5KG51bVZlcnRpY2VzICogMyk7XG4gICAgICAgIC8vYWxsb2NhdGUgbWVtb3J5IG9mIGRlZmluZWQgc2l6ZSAodG8gYXZvaWQgcmVhbGxvY2F0aW9uIG9mIG1lbW9yeSlcbiAgICAgICAgc2VsZi5pbmRpY2VzID0gbmV3IFVpbnQzMkFycmF5KG51bU9mVHJpYW5nbGVzICogMyk7XG4gICAgICAgIHNlbGYubm9ybWFscyA9IG5ldyBVaW50OEFycmF5KG51bU9mVHJpYW5nbGVzICogNik7XG4gICAgICAgIC8vaW5kaWNlcyBmb3IgaW5jcmVtZW50YWwgYWRkaW5nIG9mIGluZGljZXMgYW5kIG5vcm1hbHNcbiAgICAgICAgdmFyIGlJbmRleCA9IDA7XG4gICAgICAgIHZhciByZWFkSW5kZXg7XG4gICAgICAgIGlmIChudW1WZXJ0aWNlcyA8PSAweEZGKSB7XG4gICAgICAgICAgICByZWFkSW5kZXggPSBmdW5jdGlvbiAoY291bnQpIHsgcmV0dXJuIGJpblJlYWRlci5yZWFkQnl0ZUFycmF5KGNvdW50KTsgfTtcbiAgICAgICAgfSBlbHNlIGlmIChudW1WZXJ0aWNlcyA8PSAweEZGRkYpIHtcbiAgICAgICAgICAgIHJlYWRJbmRleCA9IGZ1bmN0aW9uIChjb3VudCkgeyByZXR1cm4gYmluUmVhZGVyLnJlYWRVaW50MTZBcnJheShjb3VudCk7IH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWFkSW5kZXggPSBmdW5jdGlvbiAoY291bnQpIHsgcmV0dXJuIGJpblJlYWRlci5yZWFkSW50MzJBcnJheShjb3VudCk7IH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbnVtRmFjZXMgPSBiaW5SZWFkZXIucmVhZEludDMyKCk7XG5cbiAgICAgICAgaWYgKG51bVZlcnRpY2VzID09PSAwIHx8IG51bU9mVHJpYW5nbGVzID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtRmFjZXM7IGkrKykge1xuICAgICAgICAgICAgdmFyIG51bVRyaWFuZ2xlc0luRmFjZSA9IGJpblJlYWRlci5yZWFkSW50MzIoKTtcbiAgICAgICAgICAgIGlmIChudW1UcmlhbmdsZXNJbkZhY2UgPT0gMCkgY29udGludWU7XG5cbiAgICAgICAgICAgIHZhciBpc1BsYW5hciA9IG51bVRyaWFuZ2xlc0luRmFjZSA+IDA7XG4gICAgICAgICAgICBudW1UcmlhbmdsZXNJbkZhY2UgPSBNYXRoLmFicyhudW1UcmlhbmdsZXNJbkZhY2UpO1xuICAgICAgICAgICAgaWYgKGlzUGxhbmFyKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbCA9IGJpblJlYWRlci5yZWFkQnl0ZUFycmF5KDIpO1xuICAgICAgICAgICAgICAgIC8vcmVhZCBhbmQgc2V0IGFsbCBpbmRpY2VzXG4gICAgICAgICAgICAgICAgdmFyIHBsYW5hckluZGljZXMgPSByZWFkSW5kZXgoMyAqIG51bVRyaWFuZ2xlc0luRmFjZSk7XG4gICAgICAgICAgICAgICAgc2VsZi5pbmRpY2VzLnNldChwbGFuYXJJbmRpY2VzLCBpSW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1UcmlhbmdsZXNJbkZhY2UgKiAzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy9hZGQgdGhyZWUgaWRlbnRpY2FsIG5vcm1hbHMgYmVjYXVzZSB0aGlzIGlzIHBsYW5hciBidXQgbmVlZHMgdG8gYmUgZXhwYW5kZWQgZm9yIFdlYkdMXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubm9ybWFsc1tpSW5kZXggKiAyXSA9IG5vcm1hbFswXTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5ub3JtYWxzW2lJbmRleCAqIDIgKyAxXSA9IG5vcm1hbFsxXTtcbiAgICAgICAgICAgICAgICAgICAgaUluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bVRyaWFuZ2xlc0luRmFjZTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW5kaWNlc1tpSW5kZXhdID0gcmVhZEluZGV4KCk7IC8vYVxuICAgICAgICAgICAgICAgICAgICBzZWxmLm5vcm1hbHMuc2V0KGJpblJlYWRlci5yZWFkQnl0ZUFycmF5KDIpLCBpSW5kZXggKiAyKTtcbiAgICAgICAgICAgICAgICAgICAgaUluZGV4Kys7XG5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbmRpY2VzW2lJbmRleF0gPSByZWFkSW5kZXgoKTsgLy9iXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubm9ybWFscy5zZXQoYmluUmVhZGVyLnJlYWRCeXRlQXJyYXkoMiksIGlJbmRleCAqIDIpO1xuICAgICAgICAgICAgICAgICAgICBpSW5kZXgrKztcblxuICAgICAgICAgICAgICAgICAgICBzZWxmLmluZGljZXNbaUluZGV4XSA9IHJlYWRJbmRleCgpOyAvL2NcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5ub3JtYWxzLnNldChiaW5SZWFkZXIucmVhZEJ5dGVBcnJheSgyKSwgaUluZGV4ICogMik7XG4gICAgICAgICAgICAgICAgICAgIGlJbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vVGhpcyB3b3VsZCBsb2FkIG9ubHkgc2hhcGUgZGF0YSBmcm9tIGJpbmFyeSBmaWxlXG4gICAgcHVibGljIGxvYWQgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIC8vYmluYXJ5IHJlYWRpbmdcbiAgICAgICAgdmFyIGJyID0gbmV3IEJpbmFyeVJlYWRlcigpO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGJyLm9ubG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5wYXJzZShicik7XG4gICAgICAgICAgICBpZiAoc2VsZi5vbmxvYWRlZCkge1xuICAgICAgICAgICAgICAgIHNlbGYub25sb2FkZWQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGJyLmxvYWQoc291cmNlKTtcbiAgICB9XG5cblxuICAgIHB1YmxpYyB2ZXJ0aWNlczogRmxvYXQzMkFycmF5O1xuICAgIHB1YmxpYyBpbmRpY2VzOiBVaW50MzJBcnJheTtcbiAgICBwdWJsaWMgbm9ybWFsczogVWludDhBcnJheTtcblxuICAgIC8vdGhpcyBmdW5jdGlvbiB3aWxsIGdldCBjYWxsZWQgd2hlbiBsb2FkaW5nIGlzIGZpbmlzaGVkLlxuICAgIC8vVGhpcyB3b24ndCBnZXQgY2FsbGVkIGFmdGVyIHBhcnNlIHdoaWNoIGlzIHN1cHBvc2VkIHRvIGhhcHBlbiBpbiBsYXJnZSBvcGVyYXRpb24uXG4gICAgcHVibGljIG9ubG9hZGVkOiAoc2hhcGU6IFRyaWFuZ3VsYXRlZFNoYXBlKSA9PiB2b2lkO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vVmlld2VyL3RyaWFuZ3VsYXRlZC1zaGFwZS50cyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUVBO0FBQUE7QUFnRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFVQTtBQXBGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXdCQTtBQUFBO0FBdEZBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8\n");

/***/ })

/******/ });
});